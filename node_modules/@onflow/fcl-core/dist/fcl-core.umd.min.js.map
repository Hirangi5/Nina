{"version":3,"file":"fcl-core.umd.min.js","sources":["../src/VERSION.js","../src/utils/is.js","../src/exec/utils/normalize-args.js","../src/document/document.js","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network-1.1.0.js","../src/interaction-template-utils/utils/replace-string-imports.js","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network.js","../src/interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network-1.0.0.js","../src/utils/chain-id/get-chain-id.js","../src/utils/chain-id/fetch-chain-id.js","../src/exec/utils/prep-template-opts.js","../src/exec/utils/pre.js","../src/exec/query.js","../src/utils/constants.js","../src/wallet-utils/on-message-from-fcl.js","../src/utils/is-react-native.js","../src/utils/url.js","../src/wallet-utils/send-msg-to-fcl.js","../src/normalizers/service/__vsn.js","../src/wallet-utils/encode-account-proof.js","../src/wallet-utils/CompositeSignature.js","../src/wallet-utils/inject-ext-service.js","../src/app-utils/verify-signatures.js","../src/exec/verify.js","../src/default-config.js","../src/transaction/transaction-error.ts","../src/transaction/index.js","../src/events/legacy-events.js","../src/current-user/exec-service/plugins.ts","../src/discovery/utils.js","../src/discovery/services/authn.js","../src/discovery/services.js","../src/discovery/index.js","../src/interaction-template-utils/utils/hash.js","../src/interaction-template-utils/utils/generate-import.js","../src/interaction-template-utils/utils/find-imports.js","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin-1.1.0.js","../src/interaction-template-utils/generate-template-id/generate-template-id-1.1.0.js","../src/interaction-template-utils/generate-template-id/generate-template-id.js","../src/interaction-template-utils/generate-template-id/generate-template-id-1.0.0.js","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin.js","../src/interaction-template-utils/generate-dependency-pin/generate-dependency-pin-1.0.0.js","../src/interaction-template-utils/verify-dependency-pin-same-at-block.js","../src/interaction-template-utils/get-interaction-template-audits.js","../src/interaction-template-utils/get-template-argument-message.js","../src/interaction-template-utils/get-template-message.js","../src/normalizers/service/frame.js","../src/normalizers/service/back-channel-rpc.js","../src/normalizers/service/local-view.js","../src/normalizers/service/service.js","../src/normalizers/service/pre-authz.js","../src/normalizers/service/authz.js","../src/normalizers/service/authn.js","../src/normalizers/service/open-id.js","../src/normalizers/service/user-signature.js","../src/normalizers/service/account-proof.js","../src/normalizers/service/authn-refresh.js","../src/current-user/service-of-type.js","../src/current-user/build-user.js","../src/current-user/merge-services.js","../src/current-user/fetch-services.js","../src/current-user/exec-service/wc-check.ts","../src/current-user/exec-service/index.js","../src/normalizers/service/composite-signature.js","../src/current-user/index.js","../src/current-user/exec-service/strategies/utils/service-endpoint.js","../src/current-user/exec-service/strategies/utils/fetch-service.js","../src/normalizers/service/polling-response.js","../src/current-user/exec-service/strategies/utils/poll.js","../src/current-user/exec-service/strategies/utils/buildMessageHandler.js","../src/utils/chain-id/chain-id-watcher.js","../src/events/index.ts","../src/current-user/exec-service/strategies/http-post.js","../src/exec/mutate.js","../src/serialize/index.js"],"sourcesContent":["export const VERSION = PACKAGE_CURRENT_VERSION || \"TESTVERSION\"\n","const is = type => d => typeof d === type\n\nexport const isRequired = d => d != null\nexport const isObject = is(\"object\")\nexport const isString = is(\"string\")\nexport const isFunc = is(\"function\")\nexport const isNumber = is(\"number\")\n","import {isFunc} from \"../../utils/is\"\nimport * as sdk from \"@onflow/sdk\"\nimport * as t from \"@onflow/types\"\n\nexport function normalizeArgs(ax) {\n  if (isFunc(ax)) return ax(sdk.arg, t)\n  return []\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport fetchTransport from \"cross-fetch\"\nimport {config} from \"@onflow/config\"\n\nasync function httpDocumentResolver({url}) {\n  invariant(\n    typeof url !== \"undefined\",\n    \"retrieve({ url }) -- url must be defined\"\n  )\n\n  let res\n  try {\n    res = await fetchTransport(url)\n  } catch (e) {\n    throw new Error(\"httpDocumentResolver Error: Failed to retrieve document.\")\n  }\n\n  let document = res.ok ? await res.json() : null\n\n  return document\n}\n\nconst DOCUMENT_RESOLVERS = new Map([\n  [\"http\", httpDocumentResolver],\n  [\"https\", httpDocumentResolver],\n])\n\nexport async function retrieve({url}) {\n  invariant(\n    typeof url !== \"undefined\",\n    \"retrieve({ url }) -- url must be defined\"\n  )\n  invariant(\n    typeof url === \"string\",\n    \"retrieve({ url }) -- url must be a string\"\n  )\n\n  const documentResolversFromConfig = await config().where(\n    /^document\\.resolver\\./\n  )\n  Object.keys(documentResolversFromConfig).map(key => {\n    const resolverFromConfig = documentResolversFromConfig[key]\n    const resolverProtocol = key.replace(/^document\\.resolver\\./, \"\")\n    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig)\n  })\n\n  const urlParts = /^(.*):\\/\\/([A-Za-z0-9\\-\\.]+)(:[0-9]+)?(.*)$/.exec(url)\n  invariant(urlParts, \"Failed to parse URL\")\n  const protocol = urlParts[1]\n  invariant(urlParts, \"Failed to parse URL protocol\")\n\n  const resolver = DOCUMENT_RESOLVERS.get(protocol)\n  invariant(resolver, `No resolver found for protcol=${protocol}`)\n\n  let document = await resolver({url})\n\n  return document\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {replaceStringImports} from \"../utils/replace-string-imports.js\"\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {Promise<string>} - Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork110({network, template}) {\n  invariant(\n    template.f_version === \"1.1.0\",\n    \"deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0\"\n  )\n\n  // get network dependencies from template dependencies, use new string import format\n  const networkDependencies = {}\n\n  template?.data?.dependencies.forEach(dependency => {\n    dependency.contracts.forEach(contract => {\n      const contractName = contract.contract\n      contract.networks.forEach(net => {\n        if (net.network === network) {\n          networkDependencies[contractName] = net.address\n        }\n      })\n\n      invariant(\n        networkDependencies[contractName] !== undefined,\n        `deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${network} ${contractName}`\n      )\n    })\n  })\n\n  invariant(\n    Object.keys(networkDependencies).length ===\n      template?.data?.dependencies.length,\n    `deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${networkDependencies}`\n  )\n\n  invariant(\n    Object.keys(networkDependencies).length ===\n      Object.values(networkDependencies).length,\n    `deriveCadenceByNetwork110 -- Could not find all addresses for network ${network} dependencies:  ${networkDependencies}`\n  )\n\n  invariant(\n    template?.data?.cadence?.body,\n    `no cadence found -- Could not replace import dependencies: ${networkDependencies}`\n  )\n\n  return replaceStringImports({\n    cadence: template?.data?.cadence?.body,\n    networkDependencies,\n  })\n}\n","/**\n * @description - Replaces string imports with the actual contract address\n *\n * @param {object} param\n * @param {string} param.cadence\n * @param {object} param.networkDependencies\n * @returns {string} - Cadence\n */\nexport function replaceStringImports({cadence, networkDependencies}) {\n  return Object.keys(networkDependencies).reduce((c, contractName) => {\n    const address = networkDependencies[contractName]\n    const regex = new RegExp(`import \"\\\\b${contractName}\\\\b\"`, \"g\")\n    return c.replace(regex, `import ${contractName} from ${address}`)\n  }, cadence)\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {deriveCadenceByNetwork100} from \"./derive-cadence-by-network-1.0.0.js\"\nimport {deriveCadenceByNetwork110} from \"./derive-cadence-by-network-1.1.0.js\"\n\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {Promise<string>} - Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork({network, template}) {\n  invariant(\n    network != undefined,\n    \"deriveCadenceByNetwork({ network }) -- network must be defined\"\n  )\n  invariant(\n    typeof network === \"string\",\n    \"deriveCadenceByNetwork({ network }) -- network must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"deriveCadenceByNetwork({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"deriveCadenceByNetwork({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      return await deriveCadenceByNetwork110({network, template})\n    case \"1.0.0\":\n      return await deriveCadenceByNetwork100({network, template})\n    default:\n      throw new Error(\n        \"deriveCadenceByNetwork Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\n\n/**\n * @description Fills import addresses in Cadence for network\n *\n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {Promise<string>} - Promise that resolves with the derived Cadence code\n */\nexport async function deriveCadenceByNetwork100({network, template}) {\n  invariant(\n    template.f_version === \"1.0.0\",\n    \"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0\"\n  )\n\n  const networkDependencies = Object.keys(template?.data?.dependencies).map(\n    dependencyPlaceholder => {\n      const dependencyNetworkContracts = Object.values(\n        template?.data?.dependencies?.[dependencyPlaceholder]\n      )\n\n      invariant(\n        dependencyNetworkContracts !== undefined,\n        `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`\n      )\n\n      invariant(\n        dependencyNetworkContracts.length > 0,\n        `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`\n      )\n\n      const dependencyContract = dependencyNetworkContracts[0]\n      const dependencyContractForNetwork = dependencyContract?.[network]\n\n      invariant(\n        dependencyContractForNetwork,\n        `deriveCadenceByNetwork100 -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`\n      )\n\n      return [dependencyPlaceholder, dependencyContractForNetwork?.address]\n    }\n  )\n\n  return networkDependencies.reduce((cadence, [placeholder, address]) => {\n    const regex = new RegExp(\"(\\\\b\" + placeholder + \"\\\\b)\", \"g\")\n    return cadence.replace(regex, address)\n  }, template.data.cadence)\n}\n","import {config} from \"@onflow/config\"\nimport {fetchChainId} from \"./fetch-chain-id\"\nimport {log} from \"@onflow/util-logger\"\n\n// Cache of chainId promises for each access node value\n// key: access node, value: chainId promise\nlet chainIdCache = {}\n\nlet hasWarnedFlowNetwork = false\nlet hasWarnedEnv = false\n\n/**\n * @description\n * Gets the chain ID if its set, otherwise gets the chain ID from the access node\n *\n * @param {object} opts - Optional parameters\n * @returns {Promise<string>} The chain ID of the access node\n * @throws {Error} If the chain ID is not found\n *\n * @example\n * // returns \"testnet\"\n * getChainId()\n */\nexport async function getChainId(opts = {}) {\n  let flowNetworkCfg = await config.get(\"flow.network\")\n  let envCfg = await config.get(\"env\")\n\n  /* \n    TODO: Add deprecation warning for flow.network config key\n    Remove this if statement when deprecation is complete\n\n    config.load() depends on flow.network config key even though this deprecation\n    warning has been available since https://github.com/onflow/fcl-js/pull/1420\n    it has effectively never been shown because of an issue in the implementation\n    of getChainId()\n\n    Showing this warning is the correct and intended behavior, but it would lead to\n    mixed messaging for users since config.load() depends on flow.network config key\n\n    We need to remove the dependency on flow.network config key from config.load()\n    before we can show this warning.\n  */\n  if (false && flowNetworkCfg && !hasWarnedFlowNetwork) {\n    log.deprecate({\n      pkg: \"FCL\",\n      subject:\n        'Using the \"flow.network\" configuration key for specifying the flow network',\n      message: \"Configuring flow.network is no longer required\",\n      transition:\n        \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-flow.network-config-key\",\n    })\n    hasWarnedFlowNetwork = true\n  }\n\n  if (envCfg && !hasWarnedEnv) {\n    log.deprecate({\n      pkg: \"FCL\",\n      subject:\n        'Using the \"env\" configuration key for specifying the flow network',\n      message: \"Configuring to specify flow network is no longer required\",\n      transition:\n        \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key\",\n    })\n    hasWarnedEnv = true\n  }\n\n  const accessNode = opts.node || (await config.get(\"accessNode.api\"))\n  if (!accessNode) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg\n    } else if (envCfg) {\n      return envCfg\n    }\n\n    throw new Error(\n      `Either the \"accessNode.api\" config key or opts.node must be set`\n    )\n  }\n\n  // Try using cached chainId first if it exists and access node is the same\n  if (chainIdCache[accessNode]) {\n    try {\n      return await chainIdCache[accessNode]\n    } catch {}\n  }\n\n  // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node\n  // Check if another getChainId() call has already started a new promise, if not, start a new one\n  // There may have been concurrent calls to getChainId() while the first call was waiting for the response\n  if (!chainIdCache[accessNode]) {\n    chainIdCache[accessNode] = fetchChainId(opts).catch(error => {\n      // If there was an error, reset the promise so that the next call will try again\n      chainIdCache[accessNode] = null\n      throw error\n    })\n  }\n\n  // Use newly created promise\n  try {\n    return await chainIdCache[accessNode]\n  } catch (e) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg\n    } else if (envCfg) {\n      return envCfg\n    }\n\n    throw new Error(\n      `Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`\n    )\n  }\n}\n\n/**\n * @description\n * Clears the chainId cache, useful for testing\n */\nexport function clearChainIdCache() {\n  chainIdCache = {}\n}\n","import * as sdk from \"@onflow/sdk\"\n\nexport async function fetchChainId(opts = {}) {\n  const response = await sdk\n    .send([sdk.getNetworkParameters()], opts)\n    .then(sdk.decode)\n  return response.chainId\n}\n","import {retrieve} from \"../../document/document.js\"\nimport {deriveCadenceByNetwork} from \"../../interaction-template-utils/derive-cadence-by-network/derive-cadence-by-network.js\"\nimport {isString} from \"../../utils/is\"\nimport {getChainId} from \"../../utils\"\n\nexport async function prepTemplateOpts(opts) {\n  if (isString(opts?.template)) {\n    opts.template = await retrieve({url: opts?.template})\n  }\n\n  const cadence =\n    opts.cadence ||\n    (await deriveCadenceByNetwork({\n      template: opts.template,\n      network: await getChainId(opts),\n    }))\n\n  opts.cadence = cadence\n\n  return opts\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport * as sdk from \"@onflow/sdk\"\nimport {isRequired, isObject, isString} from \"../../utils/is\"\n\nasync function pre(type, opts) {\n  // prettier-ignore\n  invariant(isRequired(opts), `${type}(opts) -- opts is required`)\n  // prettier-ignore\n  invariant(isObject(opts), `${type}(opts) -- opts must be an object`)\n  // prettier-ignore\n  invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`)\n  // prettier-ignore\n  invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`)\n  // // prettier-ignore\n  invariant(\n    isString(opts.cadence) || opts?.template,\n    `${type}({ cadence }) -- cadence must be a string`\n  )\n  // prettier-ignore\n  invariant(\n    await sdk.config().get(\"accessNode.api\"),\n    `${type}(opts) -- Required value for \"accessNode.api\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`\n  )\n}\n\nexport async function preMutate(opts) {\n  return pre(\"mutate\", opts)\n}\n\nexport async function preQuery(opts) {\n  return pre(\"query\", opts)\n}\n","import * as sdk from \"@onflow/sdk\"\nimport {normalizeArgs} from \"./utils/normalize-args\"\nimport {prepTemplateOpts} from \"./utils/prep-template-opts.js\"\nimport {preQuery} from \"./utils/pre.js\"\n\n/**\n * @description\n * Allows you to submit scripts to query the blockchain.\n *\n *  @param {object} opts - Query Options and configuration\n *  @param {string} opts.cadence - Cadence Script used to query Flow\n *  @param {import(\"../fcl\").ArgsFn} [opts.args] - Arguments passed to cadence script\n *  @param {object | string} [opts.template] - Interaction Template for a script\n *  @param {number} [opts.limit]   - Compute Limit for Query\n *  @returns {Promise}\n *\n *  @example\n *    const cadence = `\n *      cadence: `\n *        access(all) fun main(a: Int, b: Int, c: Address): Int {\n *          log(c)\n *          return a + b\n *        }\n *    `.trim()\n *\n *    const args = (arg, t) => [\n *      arg(5, t.Int),\n *      arg(7, t.Int),\n *      arg(\"0xb2db43ad6bc345fec9\", t.Address),\n *    ]\n *\n *    await query({ cadence, args })\n */\nexport async function query(opts = {}) {\n  await preQuery(opts)\n  opts = await prepTemplateOpts(opts)\n\n  return sdk\n    .send([\n      sdk.script(opts.cadence),\n      sdk.args(normalizeArgs(opts.args || [])),\n      opts.limit && typeof opts.limit === \"number\" && sdk.limit(opts.limit),\n    ])\n    .then(sdk.decode)\n}\n","export const FCL_REDIRECT_URL_PARAM_NAME = \"fcl_redirect_url\"\nexport const FCL_RESPONSE_PARAM_NAME = \"fclResponseJson\"\n\nexport const CORE_STRATEGIES = {\n  \"HTTP/RPC\": \"HTTP/RPC\",\n  \"HTTP/POST\": \"HTTP/POST\",\n  \"IFRAME/RPC\": \"IFRAME/RPC\",\n  \"POP/RPC\": \"POP/RPC\",\n  \"TAB/RPC\": \"TAB/RPC\",\n  \"EXT/RPC\": \"EXT/RPC\",\n  \"DEEPLINK/RPC\": \"DEEPLINK/RPC\",\n}\n","/**\n * @description\n * Listens for messages from FCL\n *\n * @param {string} messageType - Message type\n * @param {Function} cb - Callback function\n * @returns {Function} - Function to remove event listener\n */\nexport const onMessageFromFCL = (messageType, cb = () => {}) => {\n  const buildData = data => {\n    if (data.deprecated)\n      console.warn(\"DEPRECATION NOTICE\", data.deprecated.message)\n    delete data?.body?.interaction\n\n    return data\n  }\n\n  const internal = e => {\n    const {data} = e\n    if (typeof data !== \"object\") return\n    if (typeof data == null) return\n    if (data.type !== messageType) return\n\n    cb(buildData(data))\n  }\n\n  window.addEventListener(\"message\", internal)\n  return () => window.removeEventListener(\"message\", internal)\n}\n","let _isReactNative = false\n\nexport function isReactNative() {\n  return _isReactNative\n}\n\nexport function setIsReactNative(value) {\n  _isReactNative = value\n}\n","// This is a workaround for an ongoing issue with URL in React Native\n// It does not parse the URL correctly and appends trailing slashes\n// See: https://github.com/facebook/react-native/issues/24428\n// See: https://github.com/facebook/react-native/issues/24428\n\n// The React Native team is aware of this issue but does not plan to fix it\n// since it could break existing apps, even though this is out of spec\n// See whatwg implementation: https://github.com/jsdom/whatwg-url/blob/master/lib/URL-impl.js#L6-L34\n// See react-native implementation: https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Blob/URL.js#L144-L146\n\n// This is not polyfilled globally because it could break other libraries or the user's code\nimport {isReactNative} from \"./is-react-native\"\n\nconst _URL = globalThis.URL\nexport class URL extends _URL {\n  constructor(url, base, ...args) {\n    super(url, base, ...args)\n\n    // Extra check if in React Native\n    if (!isReactNative()) {\n      return\n    }\n\n    // Fix trailing slash issue\n    if (this._url && !url.endsWith(\"/\") && this._url.endsWith(\"/\")) {\n      this._url = this._url.slice(0, -1)\n    }\n  }\n}\n","import {\n  FCL_REDIRECT_URL_PARAM_NAME,\n  FCL_RESPONSE_PARAM_NAME,\n} from \"../utils/constants\"\nimport {onMessageFromFCL} from \"./on-message-from-fcl\"\nimport {URL} from \"../utils/url\"\n\n/**\n * @description\n * Sends message to FCL window\n *\n * @param {string} type - Message type\n * @param {object} msg - Message object\n * @returns {void}\n *\n * @example\n * sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n *    f_type: \"PollingResponse\",\n *    f_vsn: \"1.0.0\",\n *    status: \"APPROVED\",\n *    reason: null,\n *    data: data,\n *  })\n */\nexport const sendMsgToFCL = (type, msg = {}) => {\n  const data = {...msg, type}\n\n  const urlParams = new URLSearchParams(window.location.search)\n  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME)\n  if (redirectUrl) {\n    const url = new URL(redirectUrl)\n    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data))\n    window.location.href = url.href\n  } else if (window.location !== window.parent.location) {\n    window.parent.postMessage({...msg, type}, \"*\")\n  } else if (window.opener) {\n    window.opener.postMessage({...msg, type}, \"*\")\n  } else {\n    throw new Error(\"Unable to communicate with parent FCL instance\")\n  }\n}\n\n/**\n * @description\n * Listens for \"FCL:VIEW:READY:RESPONSE\" and sends \"FCL:VIEW:READY\"\n *\n * @param {Function} cb - Callback function\n * @param {object} msg - Message object\n * @returns {void}\n */\nexport const ready = (cb, msg = {}) => {\n  onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", cb)\n  sendMsgToFCL(\"FCL:VIEW:READY\")\n}\n\n/**\n * @description\n * Sends \"FCL:VIEW:CLOSE\"\n *\n * @returns {void}\n */\nexport const close = () => {\n  sendMsgToFCL(\"FCL:VIEW:CLOSE\")\n}\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"APPROVED\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nexport const approve = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"APPROVED\",\n    reason: null,\n    data: data,\n  })\n}\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"DECLINED\"\n *\n * @param {string} reason - Reason for declining\n * @returns {void}\n */\nexport const decline = reason => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"DECLINED\",\n    reason: reason,\n    data: null,\n  })\n}\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"REDIRECT\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nexport const redirect = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"REDIRECT\",\n    reason: null,\n    data: data,\n  })\n}\n","export const SERVICE_PRAGMA = {\n  f_type: \"Service\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const IDENTITY_PRAGMA = {\n  f_type: \"Identity\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const PROVIDER_PRAGMA = {\n  f_type: \"Provider\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const USER_PRAGMA = {\n  f_type: \"USER\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const POLLING_RESPONSE_PRAGMA = {\n  f_type: \"PollingResponse\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const COMPOSITE_SIGNATURE_PRAGMA = {\n  f_type: \"CompositeSignature\",\n  f_vsn: \"1.0.0\",\n}\n\nexport const OPEN_ID_PRAGMA = {\n  f_type: \"OpenId\",\n  f_vsn: \"1.0.0\",\n}\n","import {sansPrefix} from \"@onflow/util-address\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {Buffer, encode as rlpEncode} from \"@onflow/rlp\"\n\nconst rightPaddedHexBuffer = (value, pad) =>\n  Buffer.from(value.padEnd(pad * 2, \"0\"), \"hex\")\n\nconst leftPaddedHexBuffer = (value, pad) =>\n  Buffer.from(value.padStart(pad * 2, \"0\"), \"hex\")\n\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8)\n\nconst nonceBuffer = nonce => Buffer.from(nonce, \"hex\")\n\nexport const encodeAccountProof = (\n  {address, nonce, appIdentifier},\n  includeDomainTag = true\n) => {\n  invariant(\n    address,\n    \"Encode Message For Provable Authn Error: address must be defined\"\n  )\n  invariant(\n    nonce,\n    \"Encode Message For Provable Authn Error: nonce must be defined\"\n  )\n  invariant(\n    appIdentifier,\n    \"Encode Message For Provable Authn Error: appIdentifier must be defined\"\n  )\n\n  invariant(\n    nonce.length >= 64,\n    \"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes\"\n  )\n\n  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(\n    Buffer.from(\"FCL-ACCOUNT-PROOF-V0.0\").toString(\"hex\"),\n    32\n  )\n\n  if (includeDomainTag) {\n    return Buffer.concat([\n      ACCOUNT_PROOF_DOMAIN_TAG,\n      rlpEncode([\n        appIdentifier,\n        addressBuffer(sansPrefix(address)),\n        nonceBuffer(nonce),\n      ]),\n    ]).toString(\"hex\")\n  }\n\n  return rlpEncode([\n    appIdentifier,\n    addressBuffer(sansPrefix(address)),\n    nonceBuffer(nonce),\n  ]).toString(\"hex\")\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {COMPOSITE_SIGNATURE_PRAGMA} from \"../normalizers/service/__vsn\"\n\n/**\n * @description\n * Constructs a new CompositeSignature instance.\n *\n * @param {string} addr - Flow Address\n * @param {number} keyId - Key ID\n * @param {string} signature - Signature as a hex string\n */\nexport function CompositeSignature(addr, keyId, signature) {\n  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type\n  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn\n  this.addr = withPrefix(addr)\n  this.keyId = Number(keyId)\n  this.signature = signature\n}\n","export function injectExtService(service) {\n  if (service.type === \"authn\" && service.endpoint != null) {\n    if (!Array.isArray(window.fcl_extensions)) {\n      window.fcl_extensions = []\n    }\n    window.fcl_extensions.push(service)\n  } else {\n    console.warn(\"Authn service is required\")\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {withPrefix, sansPrefix} from \"@onflow/util-address\"\nimport {query} from \"../exec/query\"\nimport {encodeAccountProof} from \"../wallet-utils\"\nimport {isString} from \"../utils/is\"\nimport {getChainId} from \"../utils\"\n\nconst ACCOUNT_PROOF = \"ACCOUNT_PROOF\"\nconst USER_SIGNATURE = \"USER_SIGNATURE\"\n\nexport const validateArgs = args => {\n  if (args.appIdentifier) {\n    const {appIdentifier, address, nonce, signatures} = args\n    invariant(\n      isString(appIdentifier),\n      \"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string\"\n    )\n    invariant(\n      isString(address) && sansPrefix(address).length === 16,\n      \"verifyAccountProof({ address }) -- address must be a valid address\"\n    )\n    invariant(/^[0-9a-f]+$/i.test(nonce), \"nonce must be a hex string\")\n    invariant(\n      Array.isArray(signatures) &&\n        signatures.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"),\n      \"Must include an Array of CompositeSignatures to verify\"\n    )\n    invariant(\n      signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]),\n      \"User signatures to be verified must be from a single account address\"\n    )\n    return true\n  } else {\n    const {message, address, compSigs} = args\n    invariant(\n      /^[0-9a-f]+$/i.test(message),\n      \"Signed message must be a hex string\"\n    )\n    invariant(\n      isString(address) && sansPrefix(address).length === 16,\n      \"verifyUserSignatures({ address }) -- address must be a valid address\"\n    )\n    invariant(\n      Array.isArray(compSigs) &&\n        compSigs.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"),\n      \"Must include an Array of CompositeSignatures to verify\"\n    )\n    invariant(\n      compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]),\n      \"User signatures to be verified must be from a single account address\"\n    )\n    return true\n  }\n}\n\n// TODO: pass in option for contract but we're connected to testnet\n// log address + network -> in sync?\nconst getVerifySignaturesScript = async (sig, opts) => {\n  const verifyFunction =\n    sig === \"ACCOUNT_PROOF\"\n      ? \"verifyAccountProofSignatures\"\n      : \"verifyUserSignatures\"\n\n  let network = await getChainId(opts)\n\n  const contractAddresses = {\n    testnet: \"0x74daa6f9c7ef24b1\",\n    mainnet: \"0xb4b82a1c9d21d284\",\n    previewnet: \"0x40b5b8b2ce81ea4a\",\n  }\n  const fclCryptoContract = opts.fclCryptoContract || contractAddresses[network]\n\n  invariant(\n    fclCryptoContract,\n    `${verifyFunction}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${network}. Please manually specify the FCLCrypto contract address.`\n  )\n\n  return `\n      import FCLCrypto from ${fclCryptoContract}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `\n}\n\n/**\n * @description\n * Verify a valid account proof signature or signatures for an account on Flow.\n *\n * @param {string} appIdentifier - A message string in hexadecimal format\n * @param {object} accountProofData - An object consisting of address, nonce, and signatures\n * @param {string} accountProofData.address - A Flow account address\n * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)\n * @param {object[]} accountProofData.signatures - An array of composite signatures to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed\n * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const accountProofData = {\n *   address: \"0x123\",\n *   nonce: \"F0123\"\n *   signatures: [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *  }\n *\n *  const isValid = await fcl.AppUtils.verifyAccountProof(\n *    \"AwesomeAppId\",\n *    accountProofData,\n *    {fclCryptoContract}\n *  )\n */\nexport async function verifyAccountProof(\n  appIdentifier,\n  {address, nonce, signatures},\n  opts = {}\n) {\n  validateArgs({appIdentifier, address, nonce, signatures})\n  const message = encodeAccountProof({address, nonce, appIdentifier}, false)\n\n  let signaturesArr = []\n  let keyIndices = []\n\n  for (const el of signatures) {\n    signaturesArr.push(el.signature)\n    keyIndices.push(el.keyId.toString())\n  }\n\n  return query({\n    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),\n    args: (arg, t) => [\n      arg(withPrefix(address), t.Address),\n      arg(message, t.String),\n      arg(keyIndices, t.Array(t.Int)),\n      arg(signaturesArr, t.Array(t.String)),\n    ],\n  })\n}\n\n/**\n * @description\n * Verify a valid signature/s for an account on Flow.\n *\n * @param {string} message - A message string in hexadecimal format\n * @param {Array} compSigs - An array of Composite Signatures\n * @param {string} compSigs[].addr - The account address\n * @param {number} compSigs[].keyId - The account keyId\n * @param {string} compSigs[].signature - The signature to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed\n * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const isValid = await fcl.AppUtils.verifyUserSignatures(\n *    Buffer.from('FOO').toString(\"hex\"),\n *    [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *    {fclCryptoContract}\n *  )\n */\nexport async function verifyUserSignatures(message, compSigs, opts = {}) {\n  const address = withPrefix(compSigs[0].addr)\n  validateArgs({message, address, compSigs})\n\n  let signaturesArr = []\n  let keyIndices = []\n\n  for (const el of compSigs) {\n    signaturesArr.push(el.signature)\n    keyIndices.push(el.keyId.toString())\n  }\n\n  return query({\n    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),\n    args: (arg, t) => [\n      arg(address, t.Address),\n      arg(message, t.String),\n      arg(keyIndices, t.Array(t.Int)),\n      arg(signaturesArr, t.Array(t.String)),\n    ],\n  })\n}\n","import {log} from \"@onflow/util-logger\"\nimport {verifyUserSignatures as verify} from \"../app-utils\"\n\n/**\n * Verify a valid signature/s for an account on Flow.\n *\n * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead\n *\n */\nexport const verifyUserSignatures = log.deprecate({\n  pkg: \"FCL\",\n  subject: \"fcl.verifyUserSignatures()\",\n  message: \"Please use fcl.AppUtils.verifyUserSignatures()\",\n  callback: function verifyUserSignatures(message, compSigs) {\n    return verify(message, compSigs)\n  },\n})\n","import {config} from \"@onflow/config\"\n\nexport async function configLens(regex) {\n  return Object.fromEntries(\n    Object.entries(await config().where(regex)).map(([key, value]) => [\n      key.replace(regex, \"\"),\n      value,\n    ])\n  )\n}\n","import {FvmErrorCode} from \"@onflow/typedefs\"\n\nconst ERROR_CODE_REGEX = /\\[Error Code: (\\d+)\\]/\n\nexport class TransactionError extends Error {\n  public code: FvmErrorCode\n  public type: string\n\n  private constructor(message: string, code: FvmErrorCode) {\n    super(message)\n    this.code = code\n    this.type = FvmErrorCode[code]\n  }\n\n  static fromErrorMessage(errorMessage: string): TransactionError {\n    const match = errorMessage.match(ERROR_CODE_REGEX)\n    const code = match ? parseInt(match[1], 10) : undefined\n\n    return new TransactionError(\n      errorMessage,\n      code || FvmErrorCode.UNKNOWN_ERROR\n    )\n  }\n}\n","import \"../default-config\"\nimport {\n  spawn,\n  subscriber,\n  snapshoter,\n  UPDATED,\n  SNAPSHOT,\n  INIT,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport {send as fclSend, decode, getTransactionStatus} from \"@onflow/sdk\"\nimport {HTTPRequestError} from \"@onflow/transport-http\"\nimport {grpc} from \"@improbable-eng/grpc-web\"\nimport {TransactionError} from \"./transaction-error\"\n\nconst TXID_REGEXP = /^[0-9a-fA-F]{64}$/\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Transaction} Transaction\n */\n\n/**\n * @typedef {import(\"@onflow/typedefs\").TransactionStatus} TransactionStatus\n */\n\nconst POLL = \"POLL\"\nconst TIMEOUT = \"TIMEOUT\"\n\nconst fetchTxStatus = async transactionId => {\n  return fclSend([getTransactionStatus(transactionId)]).then(decode)\n}\n\nconst isExpired = tx => tx.status === 5\nconst isSealed = tx => tx.status >= 4\nconst isExecuted = tx => tx.status >= 3\nconst isFinalized = tx => tx.status >= 2\nconst isPending = tx => tx.status >= 1\nconst isUnknown = tx => tx.status >= 0\n\nconst isDiff = (cur, next) => {\n  return JSON.stringify(cur) !== JSON.stringify(next)\n}\n\nconst makeHandlers = (opts = {}) => ({\n  [INIT]: async ctx => {\n    setTimeout(() => ctx.sendSelf(TIMEOUT), opts.txNotFoundTimeout)\n    ctx.sendSelf(POLL)\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all())\n  },\n  [TIMEOUT]: async ctx => {\n    // If status is still unknown, send a timeout error\n    if (Object.keys(ctx.all()).length === 0) {\n      ctx.fatalError(\n        new Error(\n          `TX status polling failed: no transaction was found within timeout interval (${opts.txNotFoundTimeout}ms)`\n        )\n      )\n    }\n  },\n  [POLL]: async ctx => {\n    // Helper to queue another poll\n    const poll = () => setTimeout(() => ctx.sendSelf(POLL), opts.pollRate)\n\n    let tx\n    const prevTx = ctx.all()\n    try {\n      tx = await fetchTxStatus(ctx.self())\n    } catch (e) {\n      const isHttpNotFound =\n        e instanceof HTTPRequestError && e.statusCode === 404\n      const isGrpcNotFound = e.code === grpc.Code.NotFound\n\n      // If TX is not found, suppress error and poll again\n      if (isHttpNotFound || isGrpcNotFound) {\n        return poll()\n      }\n\n      return ctx.fatalError(e)\n    }\n\n    if (!isSealed(tx)) poll()\n    if (isDiff(prevTx, tx)) ctx.broadcast(UPDATED, tx)\n    ctx.merge(tx)\n  },\n})\n\nconst scoped = transactionId => {\n  if (typeof transactionId === \"object\")\n    transactionId = transactionId.transactionId\n  if (transactionId == null) throw new Error(\"transactionId required\")\n  return transactionId\n}\n\nconst spawnTransaction =\n  (opts = {}) =>\n  transactionId => {\n    return spawn(makeHandlers(opts), scoped(transactionId))\n  }\n\n/**\n * @callback SubscriptionCallback\n * @param {TransactionStatus} txStatus\n * @returns {void}\n */\n\n/**\n * Provides methods for interacting with a transaction\n *\n * @param {string} transactionId - The transaction ID\n * @param {object} [opts] - Optional parameters\n * @param {number} [opts.pollRate=1000] - Polling rate in milliseconds\n * @param {number} [opts.txNotFoundTimeout=12500] - Timeout in milliseconds for ignoring transaction not found errors (do not modify unless you know what you are doing)\n * @returns {{\n *    snapshot: function(): Promise<TransactionStatus>,\n *    subscribe: function(SubscriptionCallback): function(): void,\n *    onceFinalized: function(): Promise<TransactionStatus>,\n *    onceExecuted: function(): Promise<TransactionStatus>,\n *    onceSealed: function(): Promise<TransactionStatus>\n * }}\n * @throws {Error} If transactionId is not a 64 byte hash string\n */\nexport function transaction(\n  transactionId,\n  opts = {txNotFoundTimeout: 12500, pollRate: 1000}\n) {\n  // Validate transactionId as 64 byte hash\n  if (!TXID_REGEXP.test(scoped(transactionId)))\n    throw new Error(\"Invalid transactionId\")\n\n  function snapshot() {\n    return snapshoter(transactionId, spawnTransaction(opts))\n  }\n\n  function subscribe(callback) {\n    return subscriber(scoped(transactionId), spawnTransaction(opts), callback)\n  }\n\n  function once(predicate) {\n    return function innerOnce(opts = {}) {\n      const suppress = opts.suppress || false\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe((txStatus, error) => {\n          if (!suppress) {\n            if (error != null) {\n              reject(error)\n              unsub()\n              return\n            } else if (txStatus.statusCode === 1) {\n              const transactionError = TransactionError.fromErrorMessage(\n                txStatus.errorMessage\n              )\n              reject(transactionError)\n              unsub()\n              return\n            }\n          } else if (predicate(txStatus)) {\n            resolve(txStatus)\n            unsub()\n          }\n        })\n      })\n    }\n  }\n\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed),\n  }\n}\n\ntransaction.isUnknown = isUnknown\ntransaction.isPending = isPending\ntransaction.isFinalized = isFinalized\ntransaction.isExecuted = isExecuted\ntransaction.isSealed = isSealed\ntransaction.isExpired = isExpired\n\nexport {TransactionError}\n","import {spawn, subscriber, SUBSCRIBE, UNSUBSCRIBE} from \"@onflow/util-actor\"\nimport {\n  config,\n  block,\n  getEventsAtBlockHeightRange,\n  send,\n  decode,\n} from \"@onflow/sdk\"\n\nconst RATE = 10000\nconst UPDATED = \"UPDATED\"\nconst TICK = \"TICK\"\nconst HIGH_WATER_MARK = \"hwm\"\n\nconst scheduleTick = async ctx => {\n  return setTimeout(\n    () => ctx.sendSelf(TICK),\n    await config().get(\"fcl.eventPollRate\", RATE)\n  )\n}\n\nconst HANDLERS = {\n  [TICK]: async ctx => {\n    if (!ctx.hasSubs()) return\n    let hwm = ctx.get(HIGH_WATER_MARK)\n    if (hwm == null) {\n      ctx.put(HIGH_WATER_MARK, await block())\n      ctx.put(TICK, await scheduleTick(ctx))\n    } else {\n      let next = await block()\n      ctx.put(HIGH_WATER_MARK, next)\n      if (hwm.height < next.height) {\n        const data = await send([\n          getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height),\n        ]).then(decode)\n        for (let d of data) ctx.broadcast(UPDATED, d.data)\n      }\n      ctx.put(TICK, await scheduleTick(ctx))\n    }\n  },\n  [SUBSCRIBE]: async (ctx, letter) => {\n    if (!ctx.hasSubs()) {\n      ctx.put(TICK, await scheduleTick(ctx))\n    }\n    ctx.subscribe(letter.from)\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n    if (!ctx.hasSubs()) {\n      clearTimeout(ctx.get(TICK))\n      ctx.delete(TICK)\n      ctx.delete(HIGH_WATER_MARK)\n    }\n  },\n}\n\nconst spawnEvents = key => spawn(HANDLERS, key)\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Event} Event\n */\n\n/**\n * @typedef {object} SubscribeObject\n * @property {Function} subscribe - The subscribe function.\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Event}\n */\n\n/**\n * @description - Subscribe to events\n * @param {string} key - A valid event name\n * @returns {SubscribeObject}\n *\n * @example\n * import * as fcl from \"@onflow/fcl\"\n * fcl.events(eventName).subscribe((event) => console.log(event))\n */\nexport function events(key) {\n  return {\n    /**\n     * @description - Subscribe to events\n     * @param {Function} callback - The callback function\n     * @returns {SubscriptionCallback}\n     */\n    subscribe: callback => subscriber(key, spawnEvents, callback),\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {LEVELS, log} from \"@onflow/util-logger\"\nimport {isRequired, isString, isObject, isFunc} from \"../../utils/is\"\nimport {CORE_STRATEGIES} from \"../../utils/constants\"\n\nconst stub = () => {\n  throw new Error(`Platform specific Core Strategies are not initialized`)\n}\n\nconst stubCoreStrategies = {\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: stub,\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n}\n\nconst supportedPlugins = [\"ServicePlugin\"]\nconst supportedServicePlugins = [\"discovery-service\"]\n\nconst validateDiscoveryPlugin = (servicePlugin: any) => {\n  const {services = [], serviceStrategy} = servicePlugin\n  invariant(Array.isArray(services), \"Services must be an array\")\n\n  for (const ds of services) {\n    invariant(\n      isRequired(ds.f_type) && ds.f_type === \"Service\",\n      \"Service is required\"\n    )\n    invariant(\n      isRequired(ds.type) && ds.type === \"authn\",\n      `Service must be type authn. Received ${ds.type}`\n    )\n    invariant(\n      ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method,\n      `Service method ${ds.method} is not supported`\n    )\n  }\n\n  invariant(isRequired(serviceStrategy), \"Service strategy is required\")\n  invariant(\n    isRequired(serviceStrategy.method) && isString(serviceStrategy.method),\n    \"Service strategy method is required\"\n  )\n  invariant(\n    isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec),\n    \"Service strategy exec function is required\"\n  )\n\n  return {discoveryServices: services, serviceStrategy}\n}\n\nconst ServiceRegistry = ({coreStrategies}: {coreStrategies: any}) => {\n  let services = new Set()\n  let strategies = new Map(Object.entries(coreStrategies))\n\n  const add = (servicePlugin: any) => {\n    invariant(\n      supportedServicePlugins.includes(servicePlugin.type),\n      `Service Plugin type ${servicePlugin.type} is not supported`\n    )\n    if (servicePlugin.type === \"discovery-service\") {\n      const {discoveryServices, serviceStrategy} =\n        validateDiscoveryPlugin(servicePlugin)\n      setServices(discoveryServices)\n      if (!strategies.has(serviceStrategy.method)) {\n        strategies.set(serviceStrategy.method, serviceStrategy.exec)\n      } else {\n        log({\n          title: `Add Service Plugin`,\n          message: `Service strategy for ${serviceStrategy.method} already exists`,\n          level: LEVELS.warn,\n        })\n      }\n    }\n  }\n\n  const setServices = (discoveryServices: any) =>\n    (services = new Set([...discoveryServices]))\n\n  const getServices = () => [...services]\n\n  const getStrategy = (method: any) => strategies.get(method)\n\n  const getStrategies = () => [...strategies.keys()]\n\n  return Object.freeze({\n    add,\n    getServices,\n    getStrategy,\n    getStrategies,\n  })\n}\n\nconst validatePlugins = (plugins: any[]) => {\n  let pluginsArray\n  invariant(!!plugins, \"No plugins supplied\")\n\n  if (!Array.isArray(plugins)) {\n    pluginsArray = [plugins]\n  } else {\n    pluginsArray = [...plugins]\n  }\n  for (const p of pluginsArray) {\n    invariant(isRequired(p.name), \"Plugin name is required\")\n    invariant(isRequired(p.f_type), \"Plugin f_type is required\")\n    invariant(\n      supportedPlugins.includes(p.f_type),\n      `Plugin type ${p.f_type} is not supported`\n    )\n  }\n\n  return pluginsArray\n}\n\nconst PluginRegistry = () => {\n  const pluginsMap = new Map()\n\n  const getPlugins = () => pluginsMap\n\n  const add = (plugins: any) => {\n    const pluginsArray = validatePlugins(plugins)\n    for (const p of pluginsArray) {\n      pluginsMap.set(p.name, p)\n      if (p.f_type === \"ServicePlugin\") {\n        serviceRegistry.add(p)\n      }\n    }\n  }\n\n  return Object.freeze({\n    add,\n    getPlugins,\n  })\n}\n\nlet serviceRegistry: ReturnType<typeof ServiceRegistry>\nconst getIsServiceRegistryInitialized = () =>\n  typeof serviceRegistry !== \"undefined\"\n\nexport const initServiceRegistry = ({\n  coreStrategies,\n}: {\n  coreStrategies: any\n}) => {\n  if (getIsServiceRegistryInitialized()) {\n    return serviceRegistry\n  }\n  const _serviceRegistry = ServiceRegistry({coreStrategies})\n  serviceRegistry = _serviceRegistry\n\n  return _serviceRegistry\n}\nexport const getServiceRegistry = () => {\n  if (!getIsServiceRegistryInitialized()) {\n    console.warn(\n      \"Registry is not initalized, it will be initialized with stub core strategies\"\n    )\n\n    return initServiceRegistry({coreStrategies: stubCoreStrategies})\n  }\n\n  return serviceRegistry\n}\nexport const pluginRegistry = PluginRegistry()\n","import {config} from \"@onflow/config\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {getServiceRegistry} from \"../current-user/exec-service/plugins\"\n\nexport const makeDiscoveryServices = async () => {\n  const extensionServices = window?.fcl_extensions || []\n  return [...extensionServices, ...getServiceRegistry().getServices()]\n}\n\nexport async function getDiscoveryService(service) {\n  const discoveryAuthnInclude = await config.get(\"discovery.authn.include\", [])\n  const discoveryFeaturesSuggested = await config.get(\n    \"discovery.features.suggested\",\n    []\n  )\n  const discoveryWalletMethod = await config.first([\n    \"discovery.wallet.method\",\n    \"discovery.wallet.method.default\",\n  ])\n  const method = service?.method ? service.method : discoveryWalletMethod\n  const endpoint =\n    service?.endpoint ??\n    (await config.first([\"discovery.wallet\", \"challenge.handshake\"]))\n\n  invariant(\n    endpoint,\n    `\n    If no service is passed to \"authenticate,\" then \"discovery.wallet\" must be defined in fcl config.\n    See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n    `\n  )\n\n  return {\n    ...service,\n    type: \"authn\",\n    endpoint,\n    method,\n    discoveryAuthnInclude,\n    discoveryFeaturesSuggested,\n  }\n}\n","import {\n  spawn,\n  subscriber,\n  snapshoter,\n  INIT,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n  send,\n} from \"@onflow/util-actor\"\nimport {getServices} from \"../services\"\nimport {LEVELS, log} from \"@onflow/util-logger\"\n\nexport const SERVICE_ACTOR_KEYS = {\n  AUTHN: \"authn\",\n  RESULTS: \"results\",\n  SNAPSHOT: \"SNAPSHOT\",\n  UPDATED: \"UPDATED\",\n  UPDATE_RESULTS: \"UPDATE_RESULTS\",\n}\n\nconst warn = (fact, msg) => {\n  if (fact) {\n    console.warn(\n      `\n      %cFCL Warning\n      ============================\n      ${msg}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,\n      \"font-weight:bold;font-family:monospace;\"\n    )\n  }\n}\n\nconst fetchServicesFromDiscovery = async () => {\n  try {\n    const services = await getServices({types: [SERVICE_ACTOR_KEYS.AUTHN]})\n    send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {\n      results: services,\n    })\n  } catch (error) {\n    log({\n      title: `${error.name} Error fetching Discovery API services.`,\n      message: error.message,\n      level: LEVELS.error,\n    })\n  }\n}\n\nconst HANDLERS = {\n  [INIT]: async ctx => {\n    warn(\n      typeof window === \"undefined\",\n      '\"fcl.discovery\" is only available in the browser.'\n    )\n    // If you call this before the window is loaded extensions will not be set yet\n    if (document.readyState === \"complete\") {\n      fetchServicesFromDiscovery()\n    } else {\n      window.addEventListener(\"load\", () => {\n        fetchServicesFromDiscovery()\n      })\n    }\n  },\n  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {\n    ctx.merge(data)\n    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {...ctx.all()})\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {...ctx.all()})\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),\n  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) =>\n    letter.reply({...ctx.all()}),\n}\n\nconst spawnProviders = () => spawn(HANDLERS, SERVICE_ACTOR_KEYS.AUTHN)\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Service} Service\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Service[]}\n */\n\n/**\n * @description\n * Discovery methods for interacting with Authn.\n *\n * @typedef {object} Authn\n * @property {Function} subscribe - Subscribe to Discovery authn services\n * @property {Function} snapshot - Get the current Discovery authn services spanshot\n * @property {Function} update - Trigger an update of authn services\n */\nconst authn = {\n  /**\n   * @description - Subscribe to Discovery authn services\n   * @param {Function} cb\n   * @returns {SubscriptionCallback}\n   */\n  subscribe: cb => subscriber(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb),\n  /**\n   * @description - Get the current Discovery authn services spanshot\n   * @returns {Service[]}\n   */\n  snapshot: () => snapshoter(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders),\n  /**\n   * @description - Trigger an update of authn services\n   * @returns {void}\n   */\n  update: () => {\n    // Only fetch services if the window is loaded\n    // Otherwise, this will be called by the INIT handler\n    if (document.readyState === \"complete\") {\n      fetchServicesFromDiscovery()\n    }\n  },\n}\n\nexport default authn\n","import {config} from \"@onflow/config\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {getServiceRegistry} from \"../current-user/exec-service/plugins\"\nimport {getChainId} from \"../utils\"\nimport {VERSION} from \"../VERSION\"\nimport {makeDiscoveryServices} from \"./utils\"\nimport {URL} from \"../utils/url\"\n\nexport async function getServices({types}) {\n  const endpoint = await config.get(\"discovery.authn.endpoint\")\n  invariant(\n    Boolean(endpoint),\n    `\"discovery.authn.endpoint\" in config must be defined.`\n  )\n\n  const include = await config.get(\"discovery.authn.include\", [])\n  const url = new URL(endpoint)\n\n  return fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      type: types,\n      fclVersion: VERSION,\n      include,\n      features: {\n        suggested: await config.get(\"discovery.features.suggested\", []),\n      },\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n      userAgent: window?.navigator?.userAgent,\n      network: await getChainId(),\n    }),\n  }).then(d => d.json())\n}\n","import authn from \"./services/authn\"\nexport {getDiscoveryService, makeDiscoveryServices} from \"./utils\"\n\nconst discovery = {\n  authn,\n}\n\nexport {discovery}\n","import {SHA3} from \"sha3\"\nimport {Buffer} from \"@onflow/rlp\"\n\nexport function genHash(utf8String) {\n  const sha = new SHA3(256)\n  sha.update(Buffer.from(utf8String, \"utf8\"))\n  return sha.digest(\"hex\")\n}\n","export function generateImport({contractName, address}) {\n  return {contractName, address, contract: \"\"}\n}\n","import {generateImport} from \"./generate-import.js\"\n\nexport function findImports(cadence) {\n  const imports = []\n\n  const importsReg = /import ((\\w|,| )+)* from 0x\\w+/g\n  const fileImports = cadence.match(importsReg) || []\n\n  for (const fileImport of fileImports) {\n    const importLineReg = /import ((\\w+|, |)*) from (0x\\w+)/g\n    const importLine = importLineReg.exec(fileImport)\n\n    const contractsReg = /((?:\\w+)+),?/g\n    const contracts = importLine[1].match(contractsReg) || []\n\n    for (const contract of contracts) {\n      imports.push(\n        generateImport({\n          address: importLine[3],\n          contractName: contract.replace(/,/g, \"\"),\n        })\n      )\n    }\n  }\n\n  return imports\n}\n","import {invariant, send, getAccount, config, decode} from \"@onflow/sdk\"\nimport {genHash} from \"../utils/hash.js\"\nimport {findImports} from \"../utils/find-imports.js\"\nimport {generateImport} from \"../utils/generate-import.js\"\n\n/**\n * @description Produces a dependency pin for a contract at current state of chain\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nexport async function generateDependencyPin110(\n  {address, contractName},\n  opts = {}\n) {\n  invariant(\n    address != undefined,\n    \"generateDependencyPin({ address }) -- address must be defined\"\n  )\n  invariant(\n    contractName != undefined,\n    \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n  )\n  invariant(\n    typeof address === \"string\",\n    \"generateDependencyPin({ address }) -- address must be a string\"\n  )\n  invariant(\n    typeof contractName === \"string\",\n    \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n  )\n\n  const horizon = [generateImport({contractName, address})]\n\n  for (const horizonImport of horizon) {\n    const account = await send(\n      [\n        getAccount(\n          await config().get(horizonImport.address, horizonImport.address)\n        ),\n      ],\n      opts\n    ).then(decode)\n\n    horizonImport.contract = account.contracts?.[horizonImport.contractName]\n\n    if (!horizonImport.contract) {\n      console.error(\"Did not find expected contract\", horizonImport, account)\n      throw new Error(\"Did not find expected contract\")\n    }\n\n    const contractImports = findImports(horizonImport.contract)\n\n    horizon.push(...contractImports)\n  }\n\n  const contractPinSelfHashesPromises = horizon.map(iport =>\n    genHash(iport.contract)\n  )\n  // genHash returns a promise, so we need to await the results of all the promises\n  const contractPinSelfHashes = await Promise.all(contractPinSelfHashesPromises)\n  const contractPinHashes = contractPinSelfHashes.join(\"\")\n\n  return genHash(contractPinHashes)\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {encode as rlpEncode} from \"@onflow/rlp\"\nimport {genHash} from \"../utils/hash.js\"\nimport {generateDependencyPin110} from \"../generate-dependency-pin/generate-dependency-pin-1.1.0.js\"\n\nasync function generateContractNetworks(contractName, networks) {\n  const values = []\n  for (const net of networks) {\n    const networkHashes = [genHash(net.network)]\n    const {address, dependency_pin_block_height} = net\n    if (net.dependency_pin) {\n      const hash = await generateDependencyPin110({\n        address,\n        contractName,\n        blockHeight: dependency_pin_block_height,\n      })\n      networkHashes.push(genHash(hash))\n    }\n    values.push(networkHashes)\n  }\n  return values\n}\n\nasync function generateContractDependencies(dependencies) {\n  const values = []\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i]\n    const contracts = []\n    for (let j = 0; j < dependency?.contracts.length; j++) {\n      const c = dependency?.contracts[j]\n      const contractName = c?.contract\n      contracts.push(genHash(contractName))\n      const contractHashes = await generateContractNetworks(\n        contractName,\n        c?.networks\n      )\n      contracts.push(contractHashes)\n    }\n    values.push(contracts)\n  }\n  return values\n}\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nexport async function generateTemplateId({template}) {\n  invariant(\n    template,\n    \"generateTemplateId({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateTemplateId({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n  )\n  invariant(\n    template.f_version === \"1.1.0\",\n    \"generateTemplateId({ template }) -- template object must be an version 1.1.0\"\n  )\n\n  const templateData = template.data\n\n  const messages = await Promise.all(\n    templateData.messages.map(async templateMessage => [\n      genHash(templateMessage.key),\n      await Promise.all(\n        templateMessage.i18n.map(async templateMessagei18n => [\n          genHash(templateMessagei18n.tag),\n          genHash(templateMessagei18n.translation),\n        ])\n      ),\n    ])\n  )\n\n  const params = await Promise.all(\n    templateData?.[\"parameters\"]\n      .sort((a, b) => a.index - b.index)\n      .map(async arg => [\n        genHash(arg.label),\n        [\n          genHash(String(arg.index)),\n          genHash(arg.type),\n          await Promise.all(\n            arg.messages.map(async argumentMessage => [\n              genHash(argumentMessage.key),\n              await Promise.all(\n                argumentMessage.i18n.map(async argumentMessagei18n => [\n                  genHash(argumentMessagei18n.tag),\n                  genHash(argumentMessagei18n.translation),\n                ])\n              ),\n            ])\n          ),\n        ],\n      ])\n  )\n\n  const dependencies = [\n    await generateContractDependencies(templateData?.dependencies),\n  ]\n\n  const encodedHex = rlpEncode([\n    genHash(template?.f_type),\n    genHash(template?.f_version),\n    genHash(templateData?.type),\n    genHash(templateData?.interface),\n    messages,\n    genHash(templateData?.cadence?.body),\n    [dependencies],\n    params,\n  ]).toString(\"hex\")\n\n  return genHash(encodedHex)\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {generateTemplateId as generateTemplateId100} from \"./generate-template-id-1.0.0.js\"\nimport {generateTemplateId as generateTemplateId110} from \"./generate-template-id-1.1.0.js\"\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nexport async function generateTemplateId({template}) {\n  invariant(\n    template,\n    \"generateTemplateId({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateTemplateId({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      return await generateTemplateId110({template})\n    case \"1.0.0\":\n      return await generateTemplateId100({template})\n    default:\n      throw new Error(\"generateTemplateId Error: Unsupported template version\")\n  }\n}\n\n/**\n * @description Verifies the given Interaction Template Id has been correctly generated\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<boolean>} - true or false, Interaction Template ID\n */\n\nexport async function verifyGeneratedTemplateId({template}) {\n  return template.id === (await generateTemplateId({template}))\n}\n","import {invariant} from \"@onflow/sdk\"\nimport {encode as rlpEncode} from \"@onflow/rlp\"\nimport {genHash} from \"../utils/hash.js\"\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nexport async function generateTemplateId({template}) {\n  invariant(\n    template != undefined,\n    \"generateTemplateId({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateTemplateId({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\"\n  )\n  invariant(\n    template.f_version === \"1.0.0\",\n    \"generateTemplateId({ template }) -- template object must be an version 1.0.0\"\n  )\n\n  const templateData = template.data\n\n  const messages = await Promise.all(\n    Object.keys(templateData.messages).map(async messageKey => [\n      genHash(messageKey),\n      await Promise.all(\n        Object.keys(templateData.messages?.[messageKey]?.i18n).map(\n          async i18nkeylanguage => [\n            genHash(i18nkeylanguage),\n            genHash(\n              templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage]\n            ),\n          ]\n        )\n      ),\n    ])\n  )\n\n  const dependencies = await Promise.all(\n    Object.keys(templateData?.dependencies).map(\n      async dependencyAddressPlaceholder => [\n        genHash(dependencyAddressPlaceholder),\n        await Promise.all(\n          Object.keys(\n            templateData?.dependencies?.[dependencyAddressPlaceholder]\n          ).map(async dependencyContract => [\n            genHash(dependencyContract),\n            await Promise.all(\n              Object.keys(\n                templateData?.dependencies?.[dependencyAddressPlaceholder]?.[\n                  dependencyContract\n                ]\n              ).map(async dependencyContractNetwork => [\n                genHash(dependencyContractNetwork),\n                [\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork].address\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork]\n                      .contract\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork]\n                      .fq_address\n                  ),\n                  genHash(\n                    templateData?.dependencies?.[\n                      dependencyAddressPlaceholder\n                    ]?.[dependencyContract]?.[dependencyContractNetwork].pin\n                  ),\n                  genHash(\n                    String(\n                      templateData?.dependencies?.[\n                        dependencyAddressPlaceholder\n                      ]?.[dependencyContract]?.[dependencyContractNetwork]\n                        .pin_block_height\n                    )\n                  ),\n                ],\n              ])\n            ),\n          ])\n        ),\n      ]\n    )\n  )\n\n  const _arguments = await Promise.all(\n    Object.keys(templateData?.[\"arguments\"]).map(async argumentLabel => [\n      genHash(argumentLabel),\n      [\n        genHash(String(templateData?.[\"arguments\"]?.[argumentLabel].index)),\n        genHash(templateData?.[\"arguments\"]?.[argumentLabel].type),\n        genHash(templateData?.[\"arguments\"]?.[argumentLabel].balance || \"\"),\n        await Promise.all(\n          Object.keys(\n            templateData?.[\"arguments\"]?.[argumentLabel].messages\n          ).map(async argumentMessageKey => [\n            genHash(argumentMessageKey),\n            await Promise.all(\n              Object.keys(\n                templateData?.[\"arguments\"]?.[argumentLabel].messages?.[\n                  argumentMessageKey\n                ].i18n\n              ).map(async i18nkeylanguage => [\n                genHash(i18nkeylanguage),\n                genHash(\n                  templateData?.[\"arguments\"]?.[argumentLabel].messages?.[\n                    argumentMessageKey\n                  ].i18n?.[i18nkeylanguage]\n                ),\n              ])\n            ),\n          ])\n        ),\n      ],\n    ])\n  )\n\n  const encodedHex = rlpEncode([\n    genHash(\"InteractionTemplate\"),\n    genHash(\"1.0.0\"),\n    genHash(templateData?.type),\n    genHash(templateData?.interface),\n    messages,\n    genHash(templateData?.cadence),\n    dependencies,\n    _arguments,\n  ]).toString(\"hex\")\n\n  return genHash(encodedHex)\n}\n","import {block, invariant} from \"@onflow/sdk\"\nimport {generateDependencyPin110} from \"./generate-dependency-pin-1.1.0.js\"\nimport {generateDependencyPin100} from \"./generate-dependency-pin-1.0.0.js\"\n\n/**\n * @description Produces a dependency pin for a contract at current state of chain\n * @param {object} params\n * @param {string} params.version - The version of the interaction template\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nexport async function generateDependencyPin(\n  {version, address, contractName},\n  opts = {}\n) {\n  invariant(\n    address != undefined,\n    \"generateDependencyPin({ address }) -- address must be defined\"\n  )\n  invariant(\n    contractName != undefined,\n    \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n  )\n  invariant(\n    typeof address === \"string\",\n    \"generateDependencyPin({ address }) -- address must be a string\"\n  )\n  invariant(\n    typeof contractName === \"string\",\n    \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n  )\n\n  switch (version) {\n    case \"1.1.0\":\n      return await generateDependencyPin110({address, contractName})\n    case \"1.0.0\":\n      return await generateDependencyPin100({address, contractName})\n    default:\n      throw new Error(\n        \"deriveCadenceByNetwork Error: Unsupported template version\"\n      )\n  }\n}\n\n/**\n * @description Produces a dependency pin for a contract at latest sealed block\n * @param {object} params\n * @param {string} params.version - The version of the interaction template\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nexport async function generateDependencyPinAtLatestSealedBlock(\n  {version, address, contractName},\n  opts = {}\n) {\n  const latestSealedBlock = await block({sealed: true}, opts)\n  const latestSealedBlockHeight = latestSealedBlock?.height\n\n  return generateDependencyPin(\n    {version, address, contractName, blockHeight: latestSealedBlockHeight},\n    opts\n  )\n}\n","import {invariant, send, getAccount, config, decode} from \"@onflow/sdk\"\nimport {genHash} from \"../utils/hash.js\"\nimport {findImports} from \"../utils/find-imports.js\"\nimport {generateImport} from \"../utils/generate-import.js\"\n\n/**\n * @description Produces a dependency pin for a contract at current state of chain\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nexport async function generateDependencyPin100(\n  {address, contractName},\n  opts = {}\n) {\n  invariant(\n    address != undefined,\n    \"generateDependencyPin({ address }) -- address must be defined\"\n  )\n  invariant(\n    contractName != undefined,\n    \"generateDependencyPin({ contractName }) -- contractName must be defined\"\n  )\n  invariant(\n    typeof address === \"string\",\n    \"generateDependencyPin({ address }) -- address must be a string\"\n  )\n  invariant(\n    typeof contractName === \"string\",\n    \"generateDependencyPin({ contractName }) -- contractName must be a string\"\n  )\n\n  const horizon = [generateImport({contractName, address})]\n\n  for (const horizonImport of horizon) {\n    const account = await send(\n      [\n        getAccount(\n          await config().get(horizonImport.address, horizonImport.address)\n        ),\n      ],\n      opts\n    ).then(decode)\n\n    horizonImport.contract = account.contracts?.[horizonImport.contractName]\n\n    if (!horizonImport.contract) {\n      console.error(\"Did not find expected contract\", horizonImport, account)\n      throw new Error(\"Did not find expected contract\")\n    }\n\n    const contractImports = findImports(horizonImport.contract)\n\n    horizon.push(...contractImports)\n  }\n\n  const contractHashes = horizon.map(iport => genHash(iport.contract))\n\n  const contractHashesJoined = contractHashes.join(\"\")\n\n  return genHash(contractHashesJoined)\n}\n","import {generateDependencyPin} from \"./generate-dependency-pin/generate-dependency-pin.js\"\nimport {invariant, block} from \"@onflow/sdk\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at a block height\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {number} params.blockHeight - Block height to check pins at\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nexport async function verifyDependencyPinsSame(\n  {template, blockHeight, network},\n  opts = {}\n) {\n  invariant(\n    template != undefined,\n    \"generateDependencyPin({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"generateDependencyPin({ template }) -- template must be an object\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  invariant(\n    network != undefined,\n    \"generateDependencyPin({ network }) network must be defined\"\n  )\n  invariant(\n    blockHeight != undefined,\n    \"generateDependencyPin({ blockHeight }) blockHeight must be defined\"\n  )\n  invariant(\n    typeof blockHeight === \"number\",\n    \"generateDependencyPin({ blockHeight }) blockHeight must be a number\"\n  )\n\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const templateDependenciesPlaceholderKeys = Object.keys(\n        template.data.dependencies\n      )\n\n      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {\n        const templateDependencyPlaceholder =\n          template.data.dependencies[templateDependencyPlaceholderKey]\n\n        const templateDependencyPlaceholderContractNames = Object.keys(\n          templateDependencyPlaceholder\n        )\n\n        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {\n          const templateDependencyPlaceholderContractNetworks =\n            template.data.dependencies[templateDependencyPlaceholderKey][\n              templateDependencyPlaceholderContractName\n            ]\n\n          const templateDependency =\n            templateDependencyPlaceholderContractNetworks[network]\n          if (typeof templateDependency === \"undefined\") continue\n\n          const pin = await generateDependencyPin(\n            {\n              address: templateDependency.address,\n              contractName: templateDependency.contract,\n              blockHeight,\n            },\n            opts\n          )\n\n          if (pin !== templateDependency.pin) {\n            log({\n              title: \"verifyDependencyPinsSame Debug Error\",\n              message: `Could not recompute and match dependency pin.\n                                address: ${templateDependency.address} | contract: ${templateDependency.contract}\n                                computed: ${pin}\n                                template: ${templateDependency.pin}\n                            `,\n              level: LEVELS.debug,\n            })\n            return false\n          }\n        }\n      }\n\n      return true\n\n    case \"1.1.0\":\n      let isVerified = false\n      // iterate over each dependency\n      for (let i = 0; i < template.data?.dependencies.length; i++) {\n        const dependency = template.data?.dependencies[i]\n        // iterate over each contract in dependency\n        for (let j = 0; j < dependency?.contracts.length; j++) {\n          const contract = dependency?.contracts[j]\n          // iterate over each network in contract\n          for (let k = 0; k < contract?.networks.length; k++) {\n            const net = contract?.networks[k]\n            // if network matches, generate pin and compare\n            if (net.network === network) {\n              const pin = await generateDependencyPin(\n                {\n                  version: template.f_version,\n                  address: net.address,\n                  contractName: contract.contract,\n                  blockHeight,\n                },\n                opts\n              )\n\n              if (pin !== net.dependency_pin.pin) {\n                log({\n                  title: \"verifyDependencyPinsSame Debug Error\",\n                  message: `Could not recompute and match dependency pin.\n                                    address: ${net.address} | contract: ${contract.contract}\n                                    computed: ${pin}\n                                    template: ${net.pin}\n                                `,\n                  level: LEVELS.debug,\n                })\n                return false\n              } else {\n                isVerified = true\n              }\n            }\n          }\n        }\n      }\n      return isVerified\n\n    default:\n      throw new Error(\n        \"verifyDependencyPinsSame Error: Unsupported template version\"\n      )\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at the latest block height\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nexport async function verifyDependencyPinsSameAtLatestSealedBlock(\n  {template, network},\n  opts = {}\n) {\n  const latestSealedBlock = await block({sealed: true})\n  const latestSealedBlockHeight = latestSealedBlock?.height\n\n  return verifyDependencyPinsSame(\n    {template, network, blockHeight: latestSealedBlockHeight},\n    opts\n  )\n}\n","import {config, invariant} from \"@onflow/sdk\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {query} from \"../exec/query.js\"\nimport {generateTemplateId} from \"./generate-template-id/generate-template-id.js\"\nimport {getChainId} from \"../utils\"\n\n/**\n * @description Returns whether a set of auditors have audited a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @param {Array<string>} params.auditors - Array of auditors\n * @param {object} opts\n * @param {string} opts.flowInteractionAuditContract - Flow Interaction Template Audit contract address\n * @returns {Promise<object>} - Object of auditor addresses and audit status\n */\nexport async function getInteractionTemplateAudits(\n  {template, auditors},\n  opts = {}\n) {\n  invariant(\n    template != undefined,\n    \"getInteractionTemplateAudits({ template }) -- template must be defined\"\n  )\n  invariant(\n    template.f_type === \"InteractionTemplate\",\n    \"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate\"\n  )\n\n  // Recompute ID to be sure it matches\n  let recomputedTemplateID = await generateTemplateId({template})\n\n  if (recomputedTemplateID !== template.id) {\n    log({\n      title: \"getInteractionTemplateAudits Debug Error\",\n      message: `Could not recompute and match template ID\n                computed: ${recomputedTemplateID}\n                template: ${template.id}\n            `,\n      level: LEVELS.debug,\n    })\n    throw new Error(\n      \"getInteractionTemplateAudits Error: Could not recompute and match template ID\"\n    )\n  }\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n    case \"1.0.0\":\n      const _auditors = auditors || (await config().get(\"flow.auditors\"))\n\n      invariant(\n        _auditors,\n        \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set\"\n      )\n      invariant(\n        Array.isArray(_auditors),\n        \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array\"\n      )\n\n      let FlowInteractionAuditContract = opts.flowInteractionAuditContract\n      if (!FlowInteractionAuditContract) {\n        const fclNetwork = await getChainId(opts)\n        invariant(\n          fclNetwork === \"mainnet\" || fclNetwork === \"testnet\",\n          \"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'\"\n        )\n        if (fclNetwork === \"mainnet\") {\n          FlowInteractionAuditContract = \"0xfd100e39d50a13e6\"\n        } else {\n          FlowInteractionAuditContract = \"0xf78bfc12d0a786dc\"\n        }\n      }\n\n      const audits = await query({\n        cadence: `\n        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,\n        args: (arg, t) => [\n          arg(recomputedTemplateID, t.String),\n          arg(_auditors, t.Array(t.Address)),\n        ],\n      })\n\n      return audits\n\n    default:\n      throw new Error(\n        \"getInteractionTemplateAudits Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/sdk\"\n\n/**\n * @description Gets Interaction Template argument message by message key, argument label, and localization\n *\n * @param {object} opts\n * @param {string} opts.localization [localization=\"en-US\"] - Localization to get message for\n * @param {string} opts.argumentLabel - Argument label to get message for\n * @param {string} opts.messageKey - Message key to get message for\n * @param {object} opts.template - Interaction Template to get message from\n * @returns {string} - Message\n */\nexport function getTemplateArgumentMessage({\n  localization = \"en-US\",\n  argumentLabel,\n  messageKey,\n  template,\n}) {\n  invariant(\n    messageKey,\n    \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined\"\n  )\n  invariant(\n    typeof messageKey === \"string\",\n    \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string\"\n  )\n\n  invariant(\n    argumentLabel,\n    \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined\"\n  )\n  invariant(\n    typeof messageKey === \"string\",\n    \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string\"\n  )\n\n  invariant(\n    localization,\n    \"getTemplateArgumentMessage({ localization }) -- localization must be defined\"\n  )\n  invariant(\n    typeof localization === \"string\",\n    \"getTemplateArgumentMessage({ localization }) -- localization must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"getTemplateArgumentMessage({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"getTemplateArgumentMessage({ template }) -- template must be an object\"\n  )\n  invariant(\n    typeof template.f_type === \"InteractionTemplate\",\n    \"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      const param = template?.data?.parameters?.find(\n        a => a.label === argumentLabel\n      )\n      if (!param) return undefined\n      const message = param?.messages?.find(a => a.key === messageKey)\n      if (!message) return undefined\n      const lzn = message?.i18n?.find(a => a.tag === localization)\n      if (!lzn) return undefined\n      return lzn.translation\n    case \"1.0.0\":\n      return template?.data?.arguments?.[argumentLabel]?.messages?.[messageKey]\n        ?.i18n?.[localization]\n    default:\n      throw new Error(\n        \"getTemplateArgumentMessage Error: Unsupported template version\"\n      )\n  }\n}\n","import {invariant} from \"@onflow/sdk\"\n\n/**\n * @description Get Interaction Template argument message\n *\n * @param {object} params\n * @param {string} params.localization [localization=\"en-US\"] - Localization code\n * @param {string} params.messageKey - Message key\n * @param {object} params.template - Interaction Template\n * @returns {string} - Message\n */\nexport function getTemplateMessage({\n  localization = \"en-US\",\n  messageKey,\n  template,\n}) {\n  invariant(\n    messageKey,\n    \"getTemplateMessage({ messageKey }) -- messageKey must be defined\"\n  )\n  invariant(\n    typeof messageKey === \"string\",\n    \"getTemplateMessage({ messageKey }) -- messageKey must be a string\"\n  )\n\n  invariant(\n    localization,\n    \"getTemplateMessage({ localization }) -- localization must be defined\"\n  )\n  invariant(\n    typeof localization === \"string\",\n    \"getTemplateMessage({ localization }) -- localization must be a string\"\n  )\n\n  invariant(\n    template != undefined,\n    \"getTemplateMessage({ template }) -- template must be defined\"\n  )\n  invariant(\n    typeof template === \"object\",\n    \"getTemplateMessage({ template }) -- template must be an object\"\n  )\n  invariant(\n    typeof template.f_type === \"InteractionTemplate\",\n    \"getTemplateMessage({ template }) -- template object must be an InteractionTemplate\"\n  )\n\n  switch (template.f_version) {\n    case \"1.1.0\":\n      const msg = template?.data?.messages?.find(a => a.key === messageKey)\n      if (!msg) return undefined\n      const lzn = msg?.i18n?.find(a => a.tag === localization)\n      if (!lzn) return undefined\n      return lzn.translation\n    case \"1.0.0\":\n      return template?.data?.messages?.[messageKey]?.i18n?.[localization]\n    default:\n      throw new Error(\n        \"getTemplateArgumentMessage Error: Unsupported template version\"\n      )\n  }\n}\n","import {SERVICE_PRAGMA} from \"./__vsn\"\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"frame\",\n//    \"endpoint\": \"https://rawr\",\n//    \"data\": {},   // Sent to frame when ready\n//    \"params\": {}, // include in query params on frame\n// }\nexport function normalizeFrame(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      old: service,\n      ...SERVICE_PRAGMA,\n      type: \"frame\",\n      endpoint: service.endpoint,\n      params: service.params || {},\n      data: service.data || {},\n    }\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {SERVICE_PRAGMA} from \"./__vsn\"\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"back-channel-rpc\",\n//    \"endpoint\": \"https://rawr\",\n//    \"method\": \"HTTP/GET\", // HTTP/GET | HTTP/POST\n//    \"data\": {},           // included in body of rpc\n//    \"params\": {},         // included as query params on endpoint url\n// }\nexport function normalizeBackChannelRpc(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: \"back-channel-rpc\",\n      endpoint: service.endpoint,\n      method: service.method,\n      params: service.params || {},\n      data: service.data || {},\n    }\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {SERVICE_PRAGMA} from \"./__vsn\"\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    type: \"local-view\",\n//    method: \"VIEW/IFRAME\",\n//    endpoint: \"https://woot.org/authz/local\",\n//    data: {},\n//    params: {},\n// }\nexport function normalizeLocalView(resp) {\n  if (resp == null) return null\n  if (resp.method == null) {\n    resp = {...resp, type: \"local-view\", method: \"VIEW/IFRAME\"}\n  }\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: resp.type || \"local-view\",\n      method: resp.method,\n      endpoint: resp.endpoint,\n      data: resp.data || {},\n      params: resp.params || {},\n    }\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp\n\n    default:\n      return null\n  }\n}\n","import {normalizeAuthn} from \"./authn\"\nimport {normalizeAuthz} from \"./authz\"\nimport {normalizePreAuthz} from \"./pre-authz\"\nimport {normalizeFrame} from \"./frame\"\nimport {normalizeBackChannelRpc} from \"./back-channel-rpc\"\nimport {normalizeOpenId} from \"./open-id\"\nimport {normalizeUserSignature} from \"./user-signature\"\nimport {normalizeLocalView} from \"./local-view\"\nimport {normalizeAccountProof} from \"./account-proof\"\nimport {normalizeAuthnRefresh} from \"./authn-refresh\"\n\nexport function normalizeServices(services, data) {\n  return services\n    .map(service => normalizeService(service, data))\n    .filter(Boolean)\n}\n\nconst serviceNormalizers = {\n  \"back-channel-rpc\": normalizeBackChannelRpc,\n  \"pre-authz\": normalizePreAuthz,\n  authz: normalizeAuthz,\n  authn: normalizeAuthn,\n  frame: normalizeFrame,\n  \"open-id\": normalizeOpenId,\n  \"user-signature\": normalizeUserSignature,\n  \"local-view\": normalizeLocalView,\n  \"account-proof\": normalizeAccountProof,\n  \"authn-refresh\": normalizeAuthnRefresh,\n}\n\nexport function normalizeService(service, data) {\n  try {\n    var normalized = serviceNormalizers[service.type](service, data)\n    return normalized\n  } catch (error) {\n    console.error(\n      `Unrecognized FCL Service Type [${service.type}]`,\n      service,\n      error\n    )\n    return service\n  }\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {SERVICE_PRAGMA, IDENTITY_PRAGMA} from \"./__vsn\"\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"pre-authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of pre-authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nexport function normalizePreAuthz(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.endpoint,\n      method: service.method,\n      identity: {\n        ...IDENTITY_PRAGMA,\n        address: withPrefix(service.addr),\n        keyId: service.keyId,\n      },\n      params: service.params,\n      data: service.data,\n    }\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {SERVICE_PRAGMA, IDENTITY_PRAGMA} from \"./__vsn\"\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nexport function normalizeAuthz(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.endpoint,\n      method: service.method,\n      identity: {\n        ...IDENTITY_PRAGMA,\n        address: withPrefix(service.addr),\n        keyId: service.keyId,\n      },\n      params: service.params,\n      data: service.data,\n    }\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport {SERVICE_PRAGMA} from \"./__vsn\"\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"identity\": {\n//     \"address\": \"0x____\"\n//   },\n//   \"provider\": {\n//     \"address\": \"0x____\",\n//     \"name\": \"Best Wallet\",\n//     \"description\": \"The Best Wallet\"\n//     \"icon\": \"https://\",\n//   }\n// }\nexport function normalizeAuthn(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    return {\n      ...SERVICE_PRAGMA,\n      type: service.type,\n      uid: service.id,\n      endpoint: service.authn,\n      id: service.pid,\n      provider: {\n        address: withPrefix(service.addr),\n        name: service.name,\n        icon: service.icon,\n      },\n    }\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import {SERVICE_PRAGMA, OPEN_ID_PRAGMA} from \"./__vsn\"\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"open-id\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"method: \"data\",\n//   \"data\": {\n//      \"profile\": {\n//        \"name\": \"Bob\",\n//        \"family_name\": \"Builder\",\n//        \"given_name\": \"Robert\",\n//        \"middle_name\": \"the\",\n//        \"nickname\": \"Bob the Builder\",\n//        \"perferred_username\": \"bob\",\n//        \"profile\": \"https://www.bobthebuilder.com/\",\n//        \"picture\": \"https://avatars.onflow.org/avatar/bob\",\n//        \"gender\": \"...\",\n//        \"birthday\": \"2001-01-18\",\n//        \"zoneinfo\": \"America/Vancouver\",\n//        \"locale\": \"en-us\",\n//        \"updated_at\": \"1614970797388\"\n//      },\n//      \"email\": {\n//        \"email\": \"bob@bob.bob\",\n//        \"email_verified\": true\n//      },\n//      \"address\": {\n//        \"address\": \"One Apple Park Way, Cupertino, CA 95014, USA\"\n//      },\n//      \"phone\": {\n//        \"phone_number\": \"+1 (xxx) yyy-zzzz\",\n//        \"phone_number_verified\": true\n//      },\n//      \"social\": {\n//        \"twitter\": \"@_qvvg\",\n//        \"twitter_verified\": true\n//      },\n//   }\n// }\nexport function normalizeOpenId(service) {\n  if (service == null) return null\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"user-signature\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"IFRAME/RPC\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of user-signature request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nexport function normalizeUserSignature(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(\"Invalid user-signature service\")\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","// {\n//   \"f_type\": \"Service\",                    // Its a service!\n//   \"f_vsn\": \"1.0.0\",                       // Follows the v1.0.0 spec for the service\n//   \"type\": \"account-proof\",                // the type of service it is\n//   \"method\": \"DATA\",                       // Its data!\n//   \"uid\": \"awesome-wallet#account-proof\",  // A unique identifier for the service\n//   \"data\": {\n//     \"f_type\": \"account-proof\",\n//     \"f_vsn\": \"1.0.0\",\n//     \"nonce\": \"0A1BC2FF\",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)\n//     \"address\": \"0xUSER\",                  // The user's address (8 bytes, i.e 16 hex characters)\n//     \"signature\": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)\n// }\n\nexport function normalizeAccountProof(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(`FCL Normalizer Error: Invalid account-proof service`)\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn-refresh\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\",  // \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nexport function normalizeAuthnRefresh(service) {\n  if (service == null) return null\n\n  if (!service[\"f_vsn\"]) {\n    throw new Error(\"Invalid authn-refresh service\")\n  }\n\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service\n\n    default:\n      return null\n  }\n}\n","import * as semver from \"@onflow/util-semver\"\n\nexport function serviceOfType(services = [], type) {\n  // Find the greatest version of the service type\n  return services.reduce(\n    (mostRecent, service) =>\n      service.type === type\n        ? !mostRecent || semver.compare(service.f_vsn, mostRecent.f_vsn) > 0\n          ? service\n          : mostRecent\n        : mostRecent,\n    null\n  )\n}\n","import {withPrefix} from \"@onflow/util-address\"\nimport * as rlp from \"@onflow/rlp\"\nimport {fetchServices} from \"./fetch-services\"\nimport {mergeServices} from \"./merge-services\"\nimport {USER_PRAGMA} from \"../normalizers/service/__vsn\"\nimport {\n  normalizeService,\n  normalizeServices,\n} from \"../normalizers/service/service\"\nimport {serviceOfType} from \"./service-of-type\"\n\nfunction deriveCompositeId(authn) {\n  return rlp\n    .encode([\n      authn.provider?.address || authn.provider?.name || \"UNSPECIFIED\",\n      authn.id,\n    ])\n    .toString(\"hex\")\n}\n\nfunction normalizeData(data) {\n  data.addr = data.addr ? withPrefix(data.addr) : null\n  data.paddr = data.paddr ? withPrefix(data.paddr) : null\n  return data\n}\n\nexport async function buildUser(data) {\n  data = normalizeData(data)\n\n  var services = normalizeServices(\n    mergeServices(data.services || [], await fetchServices(data.hks, data.code))\n  )\n\n  const authn = serviceOfType(services, \"authn\")\n\n  return {\n    ...USER_PRAGMA,\n    addr: withPrefix(data.addr),\n    cid: deriveCompositeId(authn),\n    loggedIn: true,\n    services: services,\n    expiresAt: data.expires,\n  }\n}\n","export function mergeServices(sx1 = [], sx2 = []) {\n  // TODO: Make this smarter\n  return [...sx1, ...sx2]\n}\n","import {URL} from \"../utils/url\"\n\nexport async function fetchServices(servicesURL, code) {\n  if (servicesURL == null || code == null) return []\n\n  const url = new URL(servicesURL)\n  url.searchParams.append(\"code\", code)\n\n  const resp = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }).then(d => d.json())\n\n  if (Array.isArray(resp)) return resp\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services = []\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service,\n      })\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider,\n    })\n  }\n\n  return services\n}\n","import * as logger from \"@onflow/util-logger\"\nimport {getServiceRegistry} from \"./plugins\"\n\nconst FCL_WC_SERVICE_METHOD = \"WC/RPC\"\n\nconst isServerSide = typeof window === \"undefined\"\n\n// Utility to notify the user if the Walletconnect service plugin has not been loaded\nexport function checkWalletConnectEnabled() {\n  if (isServerSide) return\n\n  const serviceRegistry = getServiceRegistry()\n  const strategies = serviceRegistry.getStrategies()\n\n  if (!strategies.includes(FCL_WC_SERVICE_METHOD)) {\n    logger.log({\n      title: \"FCL WalletConnect Service Plugin\",\n      level: logger.LEVELS.error,\n      message:\n        \"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information.\",\n    })\n  }\n}\n","import {invariant} from \"@onflow/util-invariant\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {getServiceRegistry} from \"./plugins\"\nimport {getChainId} from \"../../utils\"\nimport {VERSION} from \"../../VERSION\"\nimport {configLens} from \"../../default-config\"\nimport {checkWalletConnectEnabled} from \"./wc-check\"\n\nconst AbortController =\n  globalThis.AbortController || require(\"abort-controller\")\n\nexport const execStrategy = async ({\n  service,\n  body,\n  config,\n  abortSignal,\n  customRpc,\n  user,\n  opts,\n}) => {\n  const strategy = getServiceRegistry().getStrategy(service.method)\n  return strategy({service, body, config, abortSignal, customRpc, opts, user})\n}\n\nexport async function execService({\n  service,\n  msg = {},\n  config = {},\n  opts = {},\n  platform,\n  abortSignal = new AbortController().signal,\n  execStrategy: _execStrategy,\n  user,\n}) {\n  // Notify the developer if WalletConnect is not enabled\n  checkWalletConnectEnabled()\n\n  msg.data = service.data\n  const execConfig = {\n    services: await configLens(/^service\\./),\n    app: await configLens(/^app\\.detail\\./),\n    client: {\n      ...config.client,\n      platform,\n      fclVersion: VERSION,\n      fclLibrary: \"https://github.com/onflow/fcl-js\",\n      hostname: window?.location?.hostname ?? null,\n      network: await getChainId(opts),\n    },\n  }\n\n  try {\n    const res = await (_execStrategy || execStrategy)({\n      service,\n      body: msg,\n      config: execConfig,\n      opts,\n      user,\n      abortSignal,\n    })\n\n    if (res.status === \"REDIRECT\") {\n      invariant(\n        service.type === res.data.type,\n        \"Cannot shift recursive service type in execService\"\n      )\n      return await execService({\n        service: res.data,\n        msg,\n        config: execConfig,\n        opts,\n        abortSignal,\n        platform,\n        user,\n      })\n    } else {\n      return res\n    }\n  } catch (error) {\n    log({\n      title: `Error on execService ${service?.type}`,\n      message: error,\n      level: LEVELS.error,\n    })\n    throw error\n  }\n}\n","import {COMPOSITE_SIGNATURE_PRAGMA} from \"./__vsn\"\nimport {sansPrefix} from \"@onflow/util-address\"\n\n// {\n//    \"f_type\": \"CompositeSignature\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"addr\": \"_____\",         // sans-prefix\n//    \"signature\": \"adfe1234\", // hex\n//    \"keyId\": 3,\n// }\nexport function normalizeCompositeSignature(resp) {\n  if (resp == null) return null\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...COMPOSITE_SIGNATURE_PRAGMA,\n      addr: sansPrefix(resp.addr || resp.address),\n      signature: resp.signature || resp.sig,\n      keyId: resp.keyId,\n    }\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp\n\n    default:\n      return null\n  }\n}\n","import \"../default-config\"\nimport * as t from \"@onflow/types\"\nimport {arg} from \"@onflow/sdk\"\nimport {config} from \"@onflow/config\"\nimport {spawn, send, INIT, SUBSCRIBE, UNSUBSCRIBE} from \"@onflow/util-actor\"\nimport {withPrefix, sansPrefix} from \"@onflow/util-address\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {log, LEVELS} from \"@onflow/util-logger\"\nimport {buildUser} from \"./build-user\"\nimport {serviceOfType} from \"./service-of-type\"\nimport {execService} from \"./exec-service\"\nimport {normalizeCompositeSignature} from \"../normalizers/service/composite-signature\"\nimport {getDiscoveryService, makeDiscoveryServices} from \"../discovery\"\nimport {getServiceRegistry} from \"./exec-service/plugins\"\n\n/**\n * @typedef {import(\"@onflow/typedefs\").CurrentUser} CurrentUser\n * @typedef {import(\"@onflow/typedefs\").CompositeSignature} CompositeSignature\n */\n\nexport const isFn = d => typeof d === \"function\"\n\nconst NAME = \"CURRENT_USER\"\nconst UPDATED = \"CURRENT_USER/UPDATED\"\nconst SNAPSHOT = \"SNAPSHOT\"\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\"\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\"\n\nconst DATA = `{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}`\n\nconst getStoredUser = async storage => {\n  const fallback = JSON.parse(DATA)\n  const stored = await storage.get(NAME)\n  if (stored != null && fallback[\"f_vsn\"] !== stored[\"f_vsn\"]) {\n    storage.removeItem(NAME)\n    return fallback\n  }\n  return stored || fallback\n}\n\nconst makeHandlers = cfg => {\n  // Wrapper for backwards compatibility\n  const getStorageProvider = async () => {\n    if (cfg.getStorageProvider) return await cfg.getStorageProvider()\n    return await config.first([\"fcl.storage\", \"fcl.storage.default\"])\n  }\n\n  return {\n    [INIT]: async ctx => {\n      if (typeof window === \"undefined\") {\n        console.warn(\n          `\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        `,\n          \"font-weight:bold;font-family:monospace;\"\n        )\n      }\n\n      ctx.merge(JSON.parse(DATA))\n      const storage = await getStorageProvider()\n      if (storage.can) {\n        const user = await getStoredUser(storage)\n        if (notExpired(user)) ctx.merge(user)\n      }\n    },\n    [SUBSCRIBE]: (ctx, letter) => {\n      ctx.subscribe(letter.from)\n      ctx.send(letter.from, UPDATED, {...ctx.all()})\n    },\n    [UNSUBSCRIBE]: (ctx, letter) => {\n      ctx.unsubscribe(letter.from)\n    },\n    [SNAPSHOT]: async (ctx, letter) => {\n      letter.reply({...ctx.all()})\n    },\n    [SET_CURRENT_USER]: async (ctx, letter, data) => {\n      ctx.merge(data)\n      const storage = await getStorageProvider()\n      if (storage.can) storage.put(NAME, ctx.all())\n      ctx.broadcast(UPDATED, {...ctx.all()})\n    },\n    [DEL_CURRENT_USER]: async (ctx, letter) => {\n      ctx.merge(JSON.parse(DATA))\n      const storage = await getStorageProvider()\n      if (storage.can) storage.put(NAME, ctx.all())\n      ctx.broadcast(UPDATED, {...ctx.all()})\n    },\n  }\n}\n\nconst spawnCurrentUser = cfg => spawn(makeHandlers(cfg), NAME)\n\nfunction notExpired(user) {\n  return (\n    user.expiresAt == null ||\n    user.expiresAt === 0 ||\n    user.expiresAt > Date.now()\n  )\n}\n\nasync function getAccountProofData() {\n  let accountProofDataResolver = await config.get(\"fcl.accountProof.resolver\")\n  if (accountProofDataResolver == null) return\n  if (!isFn(accountProofDataResolver)) {\n    log({\n      title: \"Account Proof Data Resolver must be a function\",\n      message: `Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}\n                `,\n      level: LEVELS.warn,\n    })\n    return\n  }\n\n  const accountProofData = await accountProofDataResolver()\n  if (accountProofData == null) return\n\n  invariant(\n    typeof accountProofData.appIdentifier === \"string\",\n    \"appIdentifier must be a string\"\n  )\n  invariant(\n    /^[0-9a-f]+$/i.test(accountProofData.nonce),\n    \"Nonce must be a hex string\"\n  )\n\n  return accountProofData\n}\n\nconst makeConfig = async ({\n  discoveryAuthnInclude,\n  discoveryFeaturesSuggested,\n}) => {\n  return {\n    client: {\n      discoveryAuthnInclude,\n      discoveryFeaturesSuggested,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n    },\n  }\n}\n\n/**\n * @description - Factory function to get the authenticate method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nconst getAuthenticate =\n  config =>\n  /**\n   * @description - Authenticate a user\n   * @param {object} [opts] - Options\n   * @param {object} [opts.service] - Optional service to use for authentication\n   * @param {boolean} [opts.redir] - Optional redirect flag\n   * @returns\n   */\n  async ({service, redir = false} = {}) => {\n    if (\n      service &&\n      !service?.provider?.is_installed &&\n      service?.provider?.requires_install\n    ) {\n      window.location.href = service?.provider?.install_link\n      return\n    }\n\n    return new Promise(async (resolve, reject) => {\n      spawnCurrentUser(config)\n      const opts = {redir}\n      const user = await getSnapshot(config)()\n      const discoveryService = await getDiscoveryService(service)\n      const refreshService = serviceOfType(user.services, \"authn-refresh\")\n      let accountProofData\n\n      if (user.loggedIn) {\n        if (refreshService) {\n          try {\n            const response = await execService({\n              service: refreshService,\n              msg: accountProofData,\n              opts,\n              platform: config.platform,\n              user,\n            })\n            send(NAME, SET_CURRENT_USER, await buildUser(response))\n          } catch (error) {\n            log({\n              title: `${error.name} Could not refresh wallet authentication.`,\n              message: error.message,\n              level: LEVELS.error,\n            })\n          } finally {\n            return resolve(await getSnapshot(config)())\n          }\n        } else {\n          return resolve(user)\n        }\n      }\n\n      try {\n        accountProofData = await getAccountProofData()\n      } catch (error) {\n        log({\n          title: `${error.name} On Authentication: Could not resolve account proof data.`,\n          message: error.message,\n          level: LEVELS.error,\n        })\n        return reject(error)\n      }\n\n      try {\n        const response = await execService({\n          service: discoveryService,\n          msg: accountProofData,\n          config: await makeConfig(discoveryService),\n          opts,\n          platform: config.platform,\n          execStrategy: config.discovery?.execStrategy,\n          user,\n        })\n\n        send(NAME, SET_CURRENT_USER, await buildUser(response))\n      } catch (error) {\n        log({\n          title: `${error} On Authentication`,\n          message: error,\n          level: LEVELS.error,\n        })\n      } finally {\n        resolve(await getSnapshot(config)())\n      }\n    })\n  }\n\n/**\n * @description - Factory function to get the unauthenticate method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nfunction getUnauthenticate(config) {\n  /**\n   * @description - Unauthenticate a user\n   */\n  return function unauthenticate() {\n    spawnCurrentUser(config)\n    send(NAME, DEL_CURRENT_USER)\n  }\n}\n\nconst normalizePreAuthzResponse = authz => ({\n  f_type: \"PreAuthzResponse\",\n  f_vsn: \"1.0.0\",\n  proposer: (authz || {}).proposer,\n  payer: (authz || {}).payer || [],\n  authorization: (authz || {}).authorization || [],\n})\n\n/**\n * @description - Factory function to get the resolvePreAuthz method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nconst getResolvePreAuthz =\n  config =>\n  (authz, {user}) => {\n    const resp = normalizePreAuthzResponse(authz)\n    const axs = []\n\n    if (resp.proposer != null) axs.push([\"PROPOSER\", resp.proposer])\n    for (let az of resp.payer || []) axs.push([\"PAYER\", az])\n    for (let az of resp.authorization || []) axs.push([\"AUTHORIZER\", az])\n\n    var result = axs.map(([role, az]) => ({\n      tempId: [az.identity.address, az.identity.keyId].join(\"|\"),\n      addr: az.identity.address,\n      keyId: az.identity.keyId,\n      signingFunction(signable) {\n        return execService({\n          service: az,\n          msg: signable,\n          platform: config.platform,\n          user,\n        })\n      },\n      role: {\n        proposer: role === \"PROPOSER\",\n        payer: role === \"PAYER\",\n        authorizer: role === \"AUTHORIZER\",\n      },\n    }))\n    return result\n  }\n\n/**\n * @description - Factory function to get the authorization method\n *\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nconst getAuthorization =\n  config =>\n  /**\n   * @description - Produces the needed authorization details for the current user to submit transactions to Flow\n   * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.\n   *\n   * @param {object} account - Account object\n   * @returns {Promise<object>} - Account object with signing function\n   * */\n  async account => {\n    spawnCurrentUser(config)\n\n    return {\n      ...account,\n      tempId: \"CURRENT_USER\",\n      async resolve(account, preSignable) {\n        const user = await getAuthenticate(config)({redir: true})\n        const authz = serviceOfType(user.services, \"authz\")\n        const preAuthz = serviceOfType(user.services, \"pre-authz\")\n\n        if (preAuthz)\n          return getResolvePreAuthz(config)(\n            await execService({\n              service: preAuthz,\n              msg: preSignable,\n              platform: config.platform,\n              user,\n            }),\n            {\n              user,\n            }\n          )\n        if (authz) {\n          return {\n            ...account,\n            tempId: \"CURRENT_USER\",\n            resolve: null,\n            addr: sansPrefix(authz.identity.address),\n            keyId: authz.identity.keyId,\n            sequenceNum: null,\n            signature: null,\n            async signingFunction(signable) {\n              return normalizeCompositeSignature(\n                await execService({\n                  service: authz,\n                  msg: signable,\n                  opts: {\n                    includeOlderJsonRpcCall: true,\n                  },\n                  platform: config.platform,\n                  user,\n                })\n              )\n            },\n          }\n        }\n        throw new Error(\n          \"No Authz or PreAuthz Service configured for CURRENT_USER\"\n        )\n      },\n    }\n  }\n\n/**\n * @description - Factory function to get the subscribe method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nfunction getSubscribe(config) {\n  /**\n   * @description\n   * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.\n   *\n   * @param {Function} callback - Callback function\n   * @returns {Function} - Unsubscribe function\n   */\n  return function subscribe(callback) {\n    spawnCurrentUser(config)\n    const EXIT = \"@EXIT\"\n    const self = spawn(async ctx => {\n      ctx.send(NAME, SUBSCRIBE)\n      while (1) {\n        const letter = await ctx.receive()\n        if (letter.tag === EXIT) {\n          ctx.send(NAME, UNSUBSCRIBE)\n          return\n        }\n        callback(letter.data)\n      }\n    })\n    return () => send(self, EXIT)\n  }\n}\n\n/**\n * @description - Factory function to get the snapshot method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nfunction getSnapshot(config) {\n  /**\n   * @description - Gets the current user\n   * @returns {Promise<CurrentUser>} - User object\n   */\n  return function snapshot() {\n    spawnCurrentUser(config)\n    return send(NAME, SNAPSHOT, null, {expectReply: true, timeout: 0})\n  }\n}\n\n/**\n * Resolves the current user as an argument\n * @param {CurrentUserConfig} config - Current User Configuration\n *\n */\nconst getResolveArgument = config => async () => {\n  const {addr} = await getAuthenticate(config)()\n  return arg(withPrefix(addr), t.Address)\n}\n\nconst makeSignable = msg => {\n  invariant(/^[0-9a-f]+$/i.test(msg), \"Message must be a hex string\")\n\n  return {\n    message: msg,\n  }\n}\n\n/**\n * @description - Factory function to get the signUserMessage method\n * @param {CurrentUserConfig} config - Current User Configuration\n */\nconst getSignUserMessage =\n  config =>\n  /**\n   * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.\n   * @param {string} msg - Message to sign\n   * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures\n   */\n  async msg => {\n    spawnCurrentUser(config)\n    const user = await getAuthenticate(config)({\n      redir: true,\n    })\n\n    const signingService = serviceOfType(user.services, \"user-signature\")\n\n    invariant(\n      signingService,\n      \"Current user must have authorized a signing service.\"\n    )\n\n    try {\n      const response = await execService({\n        service: signingService,\n        msg: makeSignable(msg),\n        platform: config.platform,\n        user,\n      })\n      if (Array.isArray(response)) {\n        return response.map(compSigs => normalizeCompositeSignature(compSigs))\n      } else {\n        return [normalizeCompositeSignature(response)]\n      }\n    } catch (error) {\n      return error\n    }\n  }\n\n/**\n * @typedef {object} CurrentUserConfig - Current User Configuration\n * @property {string} platform - Platform\n * @property {object} [discovery] - FCL Discovery Configuration\n * @property {() => Promise<import(\"../utils/storage\").StorageProvider>} [getStorageProvider] - Storage Provider Getter\n */\n\n/**\n * @description\n * Creates the Current User object\n *\n * @param {CurrentUserConfig} config - Current User Configuration\n *  */\nconst getCurrentUser = config => {\n  const currentUser = {\n    authenticate: getAuthenticate(config),\n    unauthenticate: getUnauthenticate(config),\n    authorization: getAuthorization(config),\n    signUserMessage: getSignUserMessage(config),\n    subscribe: getSubscribe(config),\n    snapshot: getSnapshot(config),\n    resolveArgument: getResolveArgument(config),\n  }\n\n  return Object.assign(\n    () => {\n      return {...currentUser}\n    },\n    {...currentUser}\n  )\n}\n\nexport {getCurrentUser}\n","import {URL} from \"../../../../utils/url\"\n\nexport function serviceEndpoint(service) {\n  const url = new URL(service.endpoint)\n  if (window?.location?.origin) {\n    url.searchParams.append(\"l6n\", window.location.origin)\n  }\n  if (service.params != null) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value)\n    }\n  }\n  return url\n}\n","import {serviceEndpoint} from \"./service-endpoint\"\n\nexport function fetchService(service, opts = {}) {\n  const method = opts.method || \"POST\"\n  const body =\n    method === \"GET\"\n      ? undefined\n      : JSON.stringify(opts.data || service.data || {})\n\n  return fetch(serviceEndpoint(service), {\n    method: method,\n    headers: {\n      ...(service.headers || {}),\n      ...(opts.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    body: body,\n  }).then(d => d.json())\n}\n","import {POLLING_RESPONSE_PRAGMA} from \"./__vsn\"\nimport {normalizeBackChannelRpc} from \"./back-channel-rpc\"\nimport {normalizeFrame} from \"./frame\"\n\n// {\n//    \"f_type\": \"PollingResponse\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"status\": \"PENDING\", // PENDING | APPROVED | DECLINED | REDIRECT\n//    \"reason\": null,      // Reason for Declining Transaction\n//    \"data\": null,        // Return value for APPROVED\n//    \"updates\": BackChannelRpc,\n//    \"local\": Frame,\n// }\nexport function normalizePollingResponse(resp) {\n  if (resp == null) return null\n\n  if (!resp[\"f_vsn\"]) {\n    return {\n      ...POLLING_RESPONSE_PRAGMA,\n      status: resp.status ?? \"APPROVED\",\n      reason: resp.reason ?? null,\n      data: resp.compositeSignature || resp.data || {...resp} || {},\n      updates: normalizeBackChannelRpc(resp.authorizationUpdates),\n      local: normalizeFrame((resp.local || [])[0]),\n    }\n  }\n\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp\n\n    default:\n      return null\n  }\n}\n","import {normalizePollingResponse} from \"../../../../normalizers/service/polling-response\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {fetchService} from \"./fetch-service\"\n\nconst OPTIONS = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\",\n}\n\nconst serviceMethod = service => {\n  invariant(\n    OPTIONS[service.method],\n    \"Invalid Service Method for type back-channel-rpc\",\n    {service}\n  )\n  return OPTIONS[service.method]\n}\n\nconst serviceBody = service => {\n  if (service.method === \"HTTP/GET\") return undefined\n  if (service.method === \"HTTP/POST\" && service.data != null)\n    return JSON.stringify(service.data)\n  return undefined\n}\n\nexport async function poll(service, checkCanContinue = () => true) {\n  invariant(service, \"Missing Polling Service\", {service})\n  const canContinue = checkCanContinue()\n  if (!canContinue) throw new Error(\"Externally Halted\")\n\n  let resp\n  try {\n    if (\n      typeof document !== \"undefined\" &&\n      document.visibilityState === \"hidden\"\n    ) {\n      await new Promise(r => setTimeout(r, 500))\n      return poll(service, checkCanContinue)\n    }\n\n    resp = await fetchService(service, {\n      method: serviceMethod(service),\n    }).then(normalizePollingResponse)\n  } catch (error) {\n    throw error\n  }\n\n  switch (resp.status) {\n    case \"APPROVED\":\n      return resp.data\n    case \"DECLINED\":\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`)\n    default:\n      await new Promise(r => setTimeout(r, 500))\n      return poll(resp.updates, checkCanContinue)\n  }\n}\n","const CLOSE_EVENT = \"FCL:VIEW:CLOSE\"\nconst READY_EVENT = \"FCL:VIEW:READY\"\nconst RESPONSE_EVENT = \"FCL:VIEW:RESPONSE\"\nconst CUSTOM_RPC = \"FCL:VIEW:CUSTOM_RPC\"\n\nconst _ = e => typeof e === \"string\" && e.toLowerCase()\n\nconst IGNORE = new Set([\n  \"monetizationstart\",\n  \"monetizationpending\",\n  \"monetizationprogress\",\n  \"monetizationstop\",\n])\n\nconst deprecate = (was, want) =>\n  console.warn(\n    \"DEPRECATION NOTICE\",\n    `Received ${was}, please use ${want} for this and future versions of FCL`\n  )\n\nexport const buildMessageHandler = ({\n  close,\n  send,\n  onReady,\n  onResponse,\n  onMessage,\n  onCustomRpc,\n  getSource,\n}) => {\n  let source\n  return e => {\n    try {\n      source = getSource?.() || source\n    } catch (_) {\n      // If getSource isn't working correctly, we should reset source\n      // to prevent desync between the source and the actual source\n      source = null\n    }\n\n    try {\n      if (typeof e.data !== \"object\") return\n      if (IGNORE.has(e.data.type)) return\n      if (source != null && e.source !== source) return\n      if (_(e.data.type) === _(CLOSE_EVENT)) close()\n      if (_(e.data.type) === _(READY_EVENT)) {\n        onReady(e, {send, close})\n        source ||= e.source\n      }\n      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {send, close})\n      if (_(e.data.type) === _(CUSTOM_RPC))\n        onCustomRpc(e.data.payload, {send, close})\n      onMessage(e, {send, close})\n\n      // Backwards Compatible\n      if (_(e.data.type) === _(\"FCL:FRAME:READY\")) {\n        deprecate(e.data.type, READY_EVENT)\n        onReady(e, {send, close})\n        source ||= e.source\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT)\n        onResponse(e, {send, close})\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:CLOSE\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n      //\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT)\n        onResponse(e, {send, close})\n      }\n      if (_(e.data.type) === _(\"FCL::AUTHZ_READY\")) {\n        deprecate(e.data.type, READY_EVENT)\n        onReady(e, {send, close})\n        source ||= e.source\n      }\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n      if (_(e.data.type) === _(\"FCL::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT)\n        close()\n      }\n    } catch (error) {\n      console.error(\"Frame Callback Error\", error)\n      close()\n    }\n  }\n}\n","import {config} from \"@onflow/config\"\nimport {getChainId} from \"./get-chain-id\"\n\n/**\n * @description\n * Watches the config for changes to access node and updates the chain id accordingly\n *\n * @returns {Function} A function that unsubscribes the listener\n *\n */\nexport function watchForChainIdChanges() {\n  return config.subscribe(() => {\n    // Call getChainId to update the chainId cache if access node has changed\n    getChainId({\n      enableRequestLogging: false,\n    }).catch(() => {})\n  })\n}\n","import {send, decode, subscribeEvents} from \"@onflow/sdk\"\nimport {Event, EventFilter, EventStream} from \"@onflow/typedefs\"\nimport {events as legacyEvents} from \"./legacy-events\"\n\n/**\n * @description - Subscribe to events\n * @param filterOrType - The filter or type of events to subscribe to\n *\n * @example\n * import * as fcl from \"@onflow/fcl\"\n * const unsubscribe = fcl.events(eventName).subscribe((event) => console.log(event))\n * unsubscribe()\n */\nexport function events(filterOrType?: EventFilter | string) {\n  let filter: EventFilter\n  if (typeof filterOrType === \"string\") {\n    filter = {eventTypes: [filterOrType]}\n  } else {\n    filter = filterOrType || {}\n  }\n\n  return {\n    subscribe: (\n      callback: (events: Event | null, error: Error | null) => void\n    ) => {\n      const streamPromise: Promise<EventStream> = send([\n        subscribeEvents(filter),\n      ]).then(decode)\n\n      // If the subscribe fails, fallback to legacy events\n      const legacySubscriptionPromise = streamPromise\n        .then(() => null)\n        .catch(e => {\n          // Only fallback to legacy events if the error is specifcally about the unsupported feature\n          if (\n            e.message !==\n            \"SDK Send Error: subscribeEvents is not supported by this transport.\"\n          ) {\n            throw e\n          }\n\n          if (typeof filterOrType !== \"string\") {\n            throw new Error(\n              \"GRPC fcl.events fallback only supports string (type) filters\"\n            )\n          }\n          return legacyEvents(filterOrType).subscribe(callback)\n        })\n\n      // Subscribe to the stream using the callback\n      function onEvents(data: Event[]) {\n        data.forEach(event => callback(event, null))\n      }\n      function onError(error: Error) {\n        callback(null, error)\n      }\n\n      // If using legacy events, don't subscribe to the stream\n      legacySubscriptionPromise.then(legacySubscription => {\n        if (!legacySubscription) {\n          streamPromise\n            .then(stream => stream.on(\"events\", onEvents).on(\"error\", onError))\n            .catch(error => {\n              streamPromise.then(stream => stream.close())\n              onError(error)\n            })\n        }\n      })\n\n      // Unsubscribe will call terminate the legacy subscription or close the stream\n      return () => {\n        legacySubscriptionPromise.then(legacySubscription => {\n          if (legacySubscription) {\n            legacySubscription()\n          } else {\n            streamPromise.then(stream => stream.close())\n          }\n        })\n      }\n    },\n  }\n}\n","import {fetchService} from \"./utils/fetch-service\"\nimport {normalizePollingResponse} from \"../../../normalizers/service/polling-response\"\nimport {normalizeLocalView} from \"../../../normalizers/service/local-view\"\nimport {poll} from \"./utils/poll\"\nimport {VERSION} from \"../../../VERSION\"\nimport {serviceEndpoint} from \"../strategies/utils/service-endpoint\"\n\nexport const getExecHttpPost =\n  execLocal =>\n  async ({service, body, config, opts}) => {\n    const resp = await fetchService(service, {\n      data: {\n        fclVersion: VERSION,\n        service: {\n          params: service.params,\n          data: service.data,\n          type: service.type,\n        },\n        config,\n        ...body,\n      },\n    }).then(normalizePollingResponse)\n\n    if (resp.status === \"APPROVED\") {\n      return resp.data\n    } else if (resp.status === \"DECLINED\") {\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`)\n    } else if (resp.status === \"REDIRECT\") {\n      return resp\n    } else if (resp.status === \"PENDING\") {\n      // these two flags are required to run polling one more time before it stops\n      var canContinue = true\n      var shouldContinue = true\n\n      const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {\n        serviceEndpoint,\n        onClose: () => (shouldContinue = false),\n      })\n\n      const close = () => {\n        try {\n          unmount()\n          shouldContinue = false\n        } catch (error) {\n          console.error(\"Frame Close Error\", error)\n        }\n      }\n      /**\n       * this function is run once per poll call.\n       * Offsetting canContinue flag to make sure that\n       * the polling is performed one extra time after canContinue flag is set to false\n       * to prevent halting on Android when a browser calls window.close\n       * before FCL receives a successful result from polling\n       *\n       * @returns {boolean}\n       */\n      const checkCanContinue = () => {\n        const offsetCanContinue = canContinue\n        canContinue = shouldContinue\n\n        return offsetCanContinue\n      }\n\n      return poll(resp.updates, checkCanContinue)\n        .then(serviceResponse => {\n          close()\n          return serviceResponse\n        })\n        .catch(error => {\n          console.error(error)\n          close()\n          throw error\n        })\n    } else {\n      console.error(`Auto Decline: Invalid Response`, {service, resp})\n      throw new Error(`Auto Decline: Invalid Response`)\n    }\n  }\n","import * as sdk from \"@onflow/sdk\"\nimport {normalizeArgs} from \"./utils/normalize-args\"\nimport {getCurrentUser} from \"../current-user\"\nimport {prepTemplateOpts} from \"./utils/prep-template-opts.js\"\nimport {preMutate} from \"./utils/pre.js\"\nimport {isNumber} from \"../utils/is\"\n\n/**\n * @description\n * Factory function that returns a mutate function for a given currentUser.\n *\n * @param {ReturnType<typeof import(\"../current-user\").getCurrentUser> | import(\"../current-user\").CurrentUserConfig} currentUserOrConfig - CurrentUser actor or configuration\n */\nexport const getMutate = currentUserOrConfig => {\n  /**\n   * @description\n   * Allows you to submit transactions to the blockchain to potentially mutate the state.\n   *\n   * @param {object} [opts] - Mutation Options and configuration\n   * @param {string} [opts.cadence] - Cadence Transaction used to mutate Flow\n   * @param {import(\"../shared-exports\").ArgsFn} [opts.args] - Arguments passed to cadence transaction\n   * @param {object | string} [opts.template] - Interaction Template for a transaction\n   * @param {number} [opts.limit] - Compute Limit for transaction\n   * @param {Function} [opts.authz] - Authorization function for transaction\n   * @param {Function} [opts.proposer] - Proposer Authorization function for transaction\n   * @param {Function} [opts.payer] - Payer Authorization function for transaction\n   * @param {Array<Function>} [opts.authorizations] - Authorizations function for transaction\n   * @returns {Promise<string>} Transaction Id\n   *\n   * @example\n   * fcl.mutate({\n   *   cadence: `\n   *     transaction(a: Int, b: Int, c: Address) {\n   *       prepare(acct: AuthAccount) {\n   *         log(acct)\n   *         log(a)\n   *         log(b)\n   *         log(c)\n   *       }\n   *     }\n   *   `,\n   *   args: (arg, t) => [\n   *     arg(6, t.Int),\n   *     arg(7, t.Int),\n   *     arg(\"0xba1132bc08f82fe2\", t.Address),\n   *   ],\n   * })\n   *\n   *\n   * Options:\n   * type Options = {\n   *   template: InteractionTemplate | String // InteractionTemplate or url to one\n   *   cadence: String!,\n   *   args: (arg, t) => Array<Arg>,\n   *   limit: Number,\n   *   authz: AuthzFn, // will overload the trinity of signatory roles\n   *   proposer: AuthzFn, // will overload the proposer signatory role\n   *   payer: AuthzFn, // will overload the payer signatory role\n   *   authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles\n   * }\n   */\n  const mutate = async (opts = {}) => {\n    var txid\n    try {\n      await preMutate(opts)\n      opts = await prepTemplateOpts(opts)\n      // Allow for a config to overwrite the authorization function.\n      // prettier-ignore\n      const currentUser = typeof currentUserOrConfig === \"function\" ? currentUserOrConfig : getCurrentUser(currentUserOrConfig)\n      const authz = await sdk\n        .config()\n        .get(\"fcl.authz\", currentUser().authorization)\n\n      txid = sdk\n        .send([\n          sdk.transaction(opts.cadence),\n\n          sdk.args(normalizeArgs(opts.args || [])),\n\n          opts.limit && isNumber(opts.limit) && sdk.limit(opts.limit),\n\n          // opts.proposer > opts.authz > authz\n          sdk.proposer(opts.proposer || opts.authz || authz),\n\n          // opts.payer > opts.authz > authz\n          sdk.payer(opts.payer || opts.authz || authz),\n\n          // opts.authorizations > [opts.authz > authz]\n          sdk.authorizations(opts.authorizations || [opts.authz || authz]),\n        ])\n        .then(sdk.decode)\n\n      return txid\n    } catch (error) {\n      throw error\n    }\n  }\n\n  return mutate\n}\n","import {interaction, pipe} from \"@onflow/sdk\"\nimport {resolve as defaultResolve} from \"@onflow/sdk\"\nimport {config, createSignableVoucher} from \"@onflow/sdk\"\n\nexport const serialize = async (args = [], opts = {}) => {\n  const resolveFunction = await config.first(\n    [\"sdk.resolve\"],\n    opts.resolve || defaultResolve\n  )\n\n  if (Array.isArray(args)) args = await pipe(interaction(), args)\n\n  return JSON.stringify(\n    createSignableVoucher(await resolveFunction(args)),\n    null,\n    2\n  )\n}\n"],"names":["VERSION","is","type","d","isRequired","isObject","isString","isFunc","isNumber","normalizeArgs","ax","sdk","arg","t","async","httpDocumentResolver","_ref","res","url","invariant","fetchTransport","e","Error","ok","json","DOCUMENT_RESOLVERS","Map","deriveCadenceByNetwork110","network","template","f_version","networkDependencies","data","dependencies","forEach","dependency","contracts","contract","contractName","networks","net","address","undefined","Object","keys","length","values","cadence","body","reduce","c","regex","RegExp","replace","replaceStringImports","deriveCadenceByNetwork","f_type","map","dependencyPlaceholder","dependencyNetworkContracts","dependencyContract","dependencyContractForNetwork","_ref2","placeholder","deriveCadenceByNetwork100","chainIdCache","hasWarnedEnv","getChainId","opts","arguments","flowNetworkCfg","config","get","envCfg","log","deprecate","pkg","subject","message","transition","accessNode","node","send","getNetworkParameters","then","decode","chainId","fetchChainId","catch","error","prepTemplateOpts","documentResolversFromConfig","where","key","resolverFromConfig","resolverProtocol","set","urlParts","exec","protocol","resolver","retrieve","pre","query","preQuery","script","args","limit","FCL_REDIRECT_URL_PARAM_NAME","FCL_RESPONSE_PARAM_NAME","CORE_STRATEGIES","onMessageFromFCL","messageType","cb","internal","deprecated","console","warn","interaction","buildData","window","addEventListener","removeEventListener","_isReactNative","isReactNative","_URL","globalThis","URL","constructor","base","_len","Array","_key","super","this","_url","endsWith","slice","sendMsgToFCL","msg","redirectUrl","URLSearchParams","location","search","searchParams","append","JSON","stringify","href","parent","postMessage","opener","SERVICE_PRAGMA","f_vsn","IDENTITY_PRAGMA","USER_PRAGMA","POLLING_RESPONSE_PRAGMA","COMPOSITE_SIGNATURE_PRAGMA","addressBuffer","addr","leftPaddedHexBuffer","value","pad","Buffer","from","padStart","nonceBuffer","nonce","encodeAccountProof","appIdentifier","includeDomainTag","ACCOUNT_PROOF_DOMAIN_TAG","toString","padEnd","rightPaddedHexBuffer","concat","rlpEncode","sansPrefix","encode","keyId","signature","withPrefix","Number","status","reason","close","service","endpoint","isArray","fcl_extensions","push","validateArgs","signatures","test","every","sig","i","arr","cs","compSigs","getVerifySignaturesScript","verifyFunction","fclCryptoContract","testnet","mainnet","previewnet","verifyUserSignatures","signaturesArr","keyIndices","el","Address","String","Int","callback","verify","configLens","fromEntries","entries","ERROR_CODE_REGEX","TransactionError","code","FvmErrorCode","fromErrorMessage","errorMessage","match","parseInt","UNKNOWN_ERROR","TXID_REGEXP","POLL","TIMEOUT","isSealed","tx","isExecuted","isFinalized","makeHandlers","INIT","setTimeout","ctx","sendSelf","txNotFoundTimeout","SUBSCRIBE","letter","subscribe","UPDATED","all","UNSUBSCRIBE","unsubscribe","SNAPSHOT","reply","fatalError","poll","pollRate","prevTx","fclSend","getTransactionStatus","transactionId","fetchTxStatus","self","isHttpNotFound","HTTPRequestError","statusCode","isGrpcNotFound","grpc","Code","NotFound","isDiff","cur","next","broadcast","merge","scoped","spawnTransaction","spawn","transaction","subscriber","once","predicate","suppress","Promise","resolve","reject","unsub","txStatus","transactionError","snapshot","snapshoter","onceFinalized","onceExecuted","onceSealed","isUnknown","isPending","isExpired","TICK","HIGH_WATER_MARK","scheduleTick","HANDLERS","hasSubs","hwm","put","block","height","getEventsAtBlockHeightRange","clearTimeout","delete","spawnEvents","stub","stubCoreStrategies","supportedPlugins","supportedServicePlugins","ServiceRegistry","coreStrategies","services","Set","strategies","setServices","discoveryServices","freeze","add","servicePlugin","includes","serviceStrategy","ds","method","validateDiscoveryPlugin","has","title","level","LEVELS","getServices","getStrategy","getStrategies","serviceRegistry","getIsServiceRegistryInitialized","initServiceRegistry","_serviceRegistry","getServiceRegistry","pluginRegistry","PluginRegistry","pluginsMap","plugins","pluginsArray","p","name","validatePlugins","getPlugins","makeDiscoveryServices","getDiscoveryService","discoveryAuthnInclude","discoveryFeaturesSuggested","discoveryWalletMethod","first","SERVICE_ACTOR_KEYS","fetchServicesFromDiscovery","types","Boolean","include","fetch","headers","fclVersion","features","suggested","clientServices","supportedStrategies","userAgent","navigator","results","fact","document","readyState","SERVICE_ACTOR_KEYS_UPDATE_RESULTS","_letter","SERVICE_ACTOR_KEYS_SNAPSHOT","spawnProviders","discovery","authn","update","genHash","utf8String","sha","SHA3","digest","generateImport","findImports","imports","fileImports","fileImport","importLine","contractsReg","generateDependencyPin110","horizon","horizonImport","account","getAccount","contractImports","contractPinSelfHashesPromises","iport","join","generateContractNetworks","networkHashes","dependency_pin_block_height","dependency_pin","hash","blockHeight","generateContractDependencies","j","contractHashes","generateTemplateId","templateData","messages","templateMessage","i18n","templateMessagei18n","tag","translation","params","sort","a","b","index","label","argumentMessage","argumentMessagei18n","encodedHex","interface","generateTemplateId110","messageKey","i18nkeylanguage","dependencyAddressPlaceholder","dependencyContractNetwork","fq_address","pin","pin_block_height","_arguments","argumentLabel","balance","argumentMessageKey","generateTemplateId100","generateDependencyPin","version","generateDependencyPin100","verifyDependencyPinsSame","templateDependenciesPlaceholderKeys","templateDependencyPlaceholderKey","templateDependencyPlaceholder","templateDependencyPlaceholderContractNames","templateDependencyPlaceholderContractName","templateDependency","debug","isVerified","k","latestSealedBlock","sealed","latestSealedBlockHeight","auditors","recomputedTemplateID","id","_auditors","FlowInteractionAuditContract","flowInteractionAuditContract","fclNetwork","audits","localization","param","parameters","find","lzn","normalizeFrame","old","normalizeBackChannelRpc","normalizeLocalView","resp","normalizeServices","serviceNormalizers","normalizeService","filter","uid","identity","authz","pid","provider","icon","frame","serviceOfType","mostRecent","semver","compare","deriveCompositeId","rlp","buildUser","mergeServices","paddr","normalizeData","servicesURL","authorizations","fetchServices","hks","cid","loggedIn","expiresAt","expires","isServerSide","AbortController","require","execStrategy","abortSignal","customRpc","user","strategy","execService","platform","signal","_execStrategy","logger","checkWalletConnectEnabled","execConfig","app","client","fclLibrary","hostname","normalizeCompositeSignature","NAME","SET_CURRENT_USER","DEL_CURRENT_USER","DATA","cfg","getStorageProvider","parse","storage","can","fallback","stored","removeItem","getStoredUser","Date","now","notExpired","spawnCurrentUser","getAccountProofData","accountProofDataResolver","accountProofData","makeConfig","getAuthenticate","redir","is_installed","requires_install","getSnapshot","discoveryService","refreshService","response","install_link","getUnauthenticate","getAuthorization","tempId","preSignable","preAuthz","proposer","payer","authorization","normalizePreAuthzResponse","axs","az","_ref3","role","signingFunction","signable","authorizer","getResolvePreAuthz","sequenceNum","includeOlderJsonRpcCall","getSubscribe","EXIT","receive","expectReply","timeout","getResolveArgument","makeSignable","getSignUserMessage","signingService","getCurrentUser","currentUser","authenticate","unauthenticate","signUserMessage","resolveArgument","assign","serviceEndpoint","origin","fetchService","normalizePollingResponse","compositeSignature","updates","authorizationUpdates","local","OPTIONS","serviceMethod","checkCanContinue","visibilityState","r","CLOSE_EVENT","READY_EVENT","RESPONSE_EVENT","_","toLowerCase","IGNORE","was","want","enableRequestLogging","source","onReady","onResponse","onMessage","onCustomRpc","getSource","payload","filterOrType","eventTypes","streamPromise","subscribeEvents","legacySubscriptionPromise","onEvents","event","onError","legacySubscription","stream","on","execLocal","canContinue","shouldContinue","unmount","onClose","offsetCanContinue","serviceResponse","currentUserOrConfig","preMutate","resolveFunction","defaultResolve","pipe","createSignableVoucher"],"mappings":"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"}