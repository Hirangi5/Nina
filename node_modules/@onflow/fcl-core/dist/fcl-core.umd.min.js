!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@onflow/sdk"),require("@onflow/types"),require("@onflow/util-invariant"),require("cross-fetch"),require("@onflow/config"),require("@onflow/util-logger"),require("@onflow/util-address"),require("@onflow/rlp"),require("@onflow/util-actor"),require("@onflow/transport-http"),require("@improbable-eng/grpc-web"),require("@onflow/typedefs"),require("sha3"),require("@onflow/util-template"),require("@onflow/util-semver")):"function"==typeof define&&define.amd?define(["exports","@onflow/sdk","@onflow/types","@onflow/util-invariant","cross-fetch","@onflow/config","@onflow/util-logger","@onflow/util-address","@onflow/rlp","@onflow/util-actor","@onflow/transport-http","@improbable-eng/grpc-web","@onflow/typedefs","sha3","@onflow/util-template","@onflow/util-semver"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["onflowFcl-core"]={},e.sdk,e.t,e.utilInvariant,e.fetchTransport,e.config,e.logger,e.utilAddress,e.rlp,e.utilActor,e.transportHttp,e.grpcWeb,e.typedefs,e.sha3,e.utilTemplate,e.semver)}(this,(function(e,t,n,r,a,i,o,s,c,l,d,u,p,f,g,m){"use strict";function y(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var v=y(t),h=y(n),b=y(o),w=y(c),E=y(m);const P="1.13.1",S=e=>t=>typeof t===e,I=e=>null!=e,T=S("object"),C=S("string"),A=S("function"),R=S("number");function k(e){return A(e)?e(v.arg,h):[]}async function O(e){let t,{url:n}=e;r.invariant(void 0!==n,"retrieve({ url }) -- url must be defined");try{t=await a(n)}catch(e){throw new Error("httpDocumentResolver Error: Failed to retrieve document.")}return t.ok?await t.json():null}const _=new Map([["http",O],["https",O]]);async function N(e){let{network:t,template:n}=e;r.invariant("1.1.0"===n.f_version,"deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0");const a={};return n?.data?.dependencies.forEach((e=>{e.contracts.forEach((e=>{const n=e.contract;e.networks.forEach((e=>{e.network===t&&(a[n]=e.address)})),r.invariant(void 0!==a[n],`deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${t} ${n}`)}))})),r.invariant(Object.keys(a).length===n?.data?.dependencies.length,`deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${a}`),r.invariant(Object.keys(a).length===Object.values(a).length,`deriveCadenceByNetwork110 -- Could not find all addresses for network ${t} dependencies:  ${a}`),r.invariant(n?.data?.cadence?.body,`no cadence found -- Could not replace import dependencies: ${a}`),function(e){let{cadence:t,networkDependencies:n}=e;return Object.keys(n).reduce(((e,t)=>{const r=n[t],a=new RegExp(`import "\\b${t}\\b"`,"g");return e.replace(a,`import ${t} from ${r}`)}),t)}({cadence:n?.data?.cadence?.body,networkDependencies:a})}async function j(e){let{network:t,template:n}=e;switch(r.invariant(null!=t,"deriveCadenceByNetwork({ network }) -- network must be defined"),r.invariant("string"==typeof t,"deriveCadenceByNetwork({ network }) -- network must be a string"),r.invariant(null!=n,"deriveCadenceByNetwork({ template }) -- template must be defined"),r.invariant("object"==typeof n,"deriveCadenceByNetwork({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate"),n.f_version){case"1.1.0":return await N({network:t,template:n});case"1.0.0":return await async function(e){let{network:t,template:n}=e;return r.invariant("1.0.0"===n.f_version,"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0"),Object.keys(n?.data?.dependencies).map((e=>{const a=Object.values(n?.data?.dependencies?.[e]);r.invariant(void 0!==a,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`),r.invariant(a.length>0,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`);const i=a[0],o=i?.[t];return r.invariant(o,`deriveCadenceByNetwork100 -- Could not find ${t} network information for dependency: ${e}`),[e,o?.address]})).reduce(((e,t)=>{let[n,r]=t;const a=new RegExp("(\\b"+n+"\\b)","g");return e.replace(a,r)}),n.data.cadence)}({network:t,template:n});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}let x={},L=!1;async function U(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=await i.config.get("flow.network"),n=await i.config.get("env");n&&!L&&(o.log.deprecate({pkg:"FCL",subject:'Using the "env" configuration key for specifying the flow network',message:"Configuring to specify flow network is no longer required",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"}),L=!0);const r=e.node||await i.config.get("accessNode.api");if(!r){if(t)return t;if(n)return n;throw new Error('Either the "accessNode.api" config key or opts.node must be set')}if(x[r])try{return await x[r]}catch{}x[r]||(x[r]=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(await v.send([v.getNetworkParameters()],e).then(v.decode)).chainId}(e).catch((e=>{throw x[r]=null,e})));try{return await x[r]}catch(e){if(t)return t;if(n)return n;throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`)}}async function D(e){C(e?.template)&&(e.template=await async function(e){let{url:t}=e;r.invariant(void 0!==t,"retrieve({ url }) -- url must be defined"),r.invariant("string"==typeof t,"retrieve({ url }) -- url must be a string");const n=await i.config().where(/^document\.resolver\./);Object.keys(n).map((e=>{const t=n[e],r=e.replace(/^document\.resolver\./,"");_.set(r,t)}));const a=/^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(t);r.invariant(a,"Failed to parse URL");const o=a[1];r.invariant(a,"Failed to parse URL protocol");const s=_.get(o);return r.invariant(s,`No resolver found for protcol=${o}`),await s({url:t})}({url:e?.template}));const t=e.cadence||await j({template:e.template,network:await U(e)});return e.cadence=t,e}async function F(e,t){r.invariant(I(t),`${e}(opts) -- opts is required`),r.invariant(T(t),`${e}(opts) -- opts must be an object`),r.invariant(!(t.cadence&&t.template),`${e}({ template, cadence }) -- cannot pass both cadence and template`),r.invariant(I(t.cadence||t?.template),`${e}({ cadence }) -- cadence is required`),r.invariant(C(t.cadence)||t?.template,`${e}({ cadence }) -- cadence must be a string`),r.invariant(await v.config().get("accessNode.api"),`${e}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)}async function B(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await async function(e){return F("query",e)}(e),e=await D(e),v.send([v.script(e.cadence),v.args(k(e.args||[])),e.limit&&"number"==typeof e.limit&&v.limit(e.limit)]).then(v.decode)}const $="fcl_redirect_url",z="fclResponseJson",M={"HTTP/RPC":"HTTP/RPC","HTTP/POST":"HTTP/POST","IFRAME/RPC":"IFRAME/RPC","POP/RPC":"POP/RPC","TAB/RPC":"TAB/RPC","EXT/RPC":"EXT/RPC","DEEPLINK/RPC":"DEEPLINK/RPC"},H=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{};const n=n=>{const{data:r}=n;"object"==typeof r&&null!=typeof r&&r.type===e&&t((e=>(e.deprecated&&console.warn("DEPRECATION NOTICE",e.deprecated.message),delete e?.body?.interaction,e))(r))};return window.addEventListener("message",n),()=>window.removeEventListener("message",n)};let q=!1;function V(){return q}const W=globalThis.URL;class K extends W{constructor(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];super(e,t,...r),V()&&this._url&&!e.endsWith("/")&&this._url.endsWith("/")&&(this._url=this._url.slice(0,-1))}}const G=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={...t,type:e},r=new URLSearchParams(window.location.search).get($);if(r){const e=new K(r);e.searchParams.append(z,JSON.stringify(n)),window.location.href=e.href}else if(window.location!==window.parent.location)window.parent.postMessage({...t,type:e},"*");else{if(!window.opener)throw new Error("Unable to communicate with parent FCL instance");window.opener.postMessage({...t,type:e},"*")}},J={f_type:"Service",f_vsn:"1.0.0"},Y={f_type:"Identity",f_vsn:"1.0.0"},X={f_type:"USER",f_vsn:"1.0.0"},Z={f_type:"PollingResponse",f_vsn:"1.0.0"},Q={f_type:"CompositeSignature",f_vsn:"1.0.0"};const ee=e=>{return t=e,n=8,c.Buffer.from(t.padStart(2*n,"0"),"hex");var t,n},te=e=>c.Buffer.from(e,"hex"),ne=function(e){let{address:t,nonce:n,appIdentifier:a}=e,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];r.invariant(t,"Encode Message For Provable Authn Error: address must be defined"),r.invariant(n,"Encode Message For Provable Authn Error: nonce must be defined"),r.invariant(a,"Encode Message For Provable Authn Error: appIdentifier must be defined"),r.invariant(n.length>=64,"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");const o=(l=c.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"),d=32,c.Buffer.from(l.padEnd(2*d,"0"),"hex"));var l,d;return i?c.Buffer.concat([o,c.encode([a,ee(s.sansPrefix(t)),te(n)])]).toString("hex"):c.encode([a,ee(s.sansPrefix(t)),te(n)]).toString("hex")};var re=Object.freeze({__proto__:null,CompositeSignature:function(e,t,n){this.f_type=Q.f_type,this.f_vsn=Q.f_vsn,this.addr=s.withPrefix(e),this.keyId=Number(t),this.signature=n},approve:e=>{G("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"APPROVED",reason:null,data:e})},close:()=>{G("FCL:VIEW:CLOSE")},decline:e=>{G("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"DECLINED",reason:e,data:null})},encodeAccountProof:ne,encodeMessageFromSignable:t.encodeMessageFromSignable,injectExtService:function(e){"authn"===e.type&&null!=e.endpoint?(Array.isArray(window.fcl_extensions)||(window.fcl_extensions=[]),window.fcl_extensions.push(e)):console.warn("Authn service is required")},onMessageFromFCL:H,ready:function(e){H("FCL:VIEW:READY:RESPONSE",e),G("FCL:VIEW:READY")},redirect:e=>{G("FCL:VIEW:RESPONSE",{f_type:"PollingResponse",f_vsn:"1.0.0",status:"REDIRECT",reason:null,data:e})},sendMsgToFCL:G});const ae=e=>{if(e.appIdentifier){const{appIdentifier:t,address:n,nonce:a,signatures:i}=e;return r.invariant(C(t),"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"),r.invariant(C(n)&&16===s.sansPrefix(n).length,"verifyAccountProof({ address }) -- address must be a valid address"),r.invariant(/^[0-9a-f]+$/i.test(a),"nonce must be a hex string"),r.invariant(Array.isArray(i)&&i.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(i.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}{const{message:t,address:n,compSigs:a}=e;return r.invariant(/^[0-9a-f]+$/i.test(t),"Signed message must be a hex string"),r.invariant(C(n)&&16===s.sansPrefix(n).length,"verifyUserSignatures({ address }) -- address must be a valid address"),r.invariant(Array.isArray(a)&&a.every(((e,t,n)=>"CompositeSignature"===e.f_type)),"Must include an Array of CompositeSignatures to verify"),r.invariant(a.map((e=>e.addr)).every(((e,t,n)=>e===n[0])),"User signatures to be verified must be from a single account address"),!0}},ie=async(e,t)=>{const n="ACCOUNT_PROOF"===e?"verifyAccountProofSignatures":"verifyUserSignatures";let a=await U(t);const i=t.fclCryptoContract||{testnet:"0x74daa6f9c7ef24b1",mainnet:"0xb4b82a1c9d21d284",previewnet:"0x40b5b8b2ce81ea4a"}[a];return r.invariant(i,`${n}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${a}. Please manually specify the FCLCrypto contract address.`),`\n      import FCLCrypto from ${i}\n\n      access(all) fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${n}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `};async function oe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=s.withPrefix(t[0].addr);ae({message:e,address:r,compSigs:t});let a=[],i=[];for(const e of t)a.push(e.signature),i.push(e.keyId.toString());return B({cadence:await ie("USER_SIGNATURE",n),args:(t,n)=>[t(r,n.Address),t(e,n.String),t(i,n.Array(n.Int)),t(a,n.Array(n.String))]})}var se=Object.freeze({__proto__:null,verifyAccountProof:async function(e,t){let{address:n,nonce:r,signatures:a}=t,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ae({appIdentifier:e,address:n,nonce:r,signatures:a});const o=ne({address:n,nonce:r,appIdentifier:e},!1);let c=[],l=[];for(const e of a)c.push(e.signature),l.push(e.keyId.toString());return B({cadence:await ie("ACCOUNT_PROOF",i),args:(e,t)=>[e(s.withPrefix(n),t.Address),e(o,t.String),e(l,t.Array(t.Int)),e(c,t.Array(t.String))]})},verifyUserSignatures:oe});const ce=o.log.deprecate({pkg:"FCL",subject:"fcl.verifyUserSignatures()",message:"Please use fcl.AppUtils.verifyUserSignatures()",callback:function(e,t){return oe(e,t)}});async function le(e){return Object.fromEntries(Object.entries(await i.config().where(e)).map((t=>{let[n,r]=t;return[n.replace(e,""),r]})))}const de=/\[Error Code: (\d+)\]/;class ue extends Error{constructor(e,t){super(e),this.code=t,this.type=p.FvmErrorCode[t]}static fromErrorMessage(e){const t=e.match(de),n=t?parseInt(t[1],10):void 0;return new ue(e,n||p.FvmErrorCode.UNKNOWN_ERROR)}}const pe=/^[0-9a-fA-F]{64}$/,fe="POLL",ge="TIMEOUT",me=e=>e.status>=4,ye=e=>e.status>=3,ve=e=>e.status>=2,he=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{[l.INIT]:async t=>{setTimeout((()=>t.sendSelf(ge)),e.txNotFoundTimeout),t.sendSelf(fe)},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,l.UPDATED,e.all())},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[l.SNAPSHOT]:async(e,t)=>{t.reply(e.all())},[ge]:async t=>{0===Object.keys(t.all()).length&&t.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${e.txNotFoundTimeout}ms)`))},[fe]:async n=>{const r=()=>setTimeout((()=>n.sendSelf(fe)),e.pollRate);let a;const i=n.all();try{a=await(async e=>t.send([t.getTransactionStatus(e)]).then(t.decode))(n.self())}catch(e){const t=e instanceof d.HTTPRequestError&&404===e.statusCode,a=e.code===u.grpc.Code.NotFound;return t||a?r():n.fatalError(e)}var o,s;me(a)||r(),o=i,s=a,JSON.stringify(o)!==JSON.stringify(s)&&n.broadcast(l.UPDATED,a),n.merge(a)}}},be=e=>{if("object"==typeof e&&(e=e.transactionId),null==e)throw new Error("transactionId required");return e},we=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>l.spawn(he(e),be(t))};function Ee(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:1e3};if(!pe.test(be(e)))throw new Error("Invalid transactionId");function n(n){return l.subscriber(be(e),we(t),n)}function r(e){return function(){const t=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).suppress||!1;return new Promise(((r,a)=>{const i=n(((n,o)=>{if(t)e(n)&&(r(n),i());else{if(null!=o)return a(o),void i();if(1===n.statusCode){const e=ue.fromErrorMessage(n.errorMessage);return a(e),void i()}}}))}))}}return{snapshot:function(){return l.snapshoter(e,we(t))},subscribe:n,onceFinalized:r(ve),onceExecuted:r(ye),onceSealed:r(me)}}Ee.isUnknown=e=>e.status>=0,Ee.isPending=e=>e.status>=1,Ee.isFinalized=ve,Ee.isExecuted=ye,Ee.isSealed=me,Ee.isExpired=e=>5===e.status;const Pe="TICK",Se="hwm",Ie=async e=>setTimeout((()=>e.sendSelf(Pe)),await t.config().get("fcl.eventPollRate",1e4)),Te={[Pe]:async e=>{if(!e.hasSubs())return;let n=e.get(Se);if(null==n)e.put(Se,await t.block()),e.put(Pe,await Ie(e));else{let r=await t.block();if(e.put(Se,r),n.height<r.height){const a=await t.send([t.getEventsAtBlockHeightRange(e.self(),n.height+1,r.height)]).then(t.decode);for(let t of a)e.broadcast("UPDATED",t.data)}e.put(Pe,await Ie(e))}},[l.SUBSCRIBE]:async(e,t)=>{e.hasSubs()||e.put(Pe,await Ie(e)),e.subscribe(t.from)},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from),e.hasSubs()||(clearTimeout(e.get(Pe)),e.delete(Pe),e.delete(Se))}},Ce=e=>l.spawn(Te,e);const Ae=()=>{throw new Error("Platform specific Core Strategies are not initialized")},Re={[M["EXT/RPC"]]:Ae,[M["HTTP/POST"]]:Ae,[M["IFRAME/RPC"]]:Ae,[M["POP/RPC"]]:Ae,[M["TAB/RPC"]]:Ae,[M["EXT/RPC"]]:Ae},ke=["ServicePlugin"],Oe=["discovery-service"],_e=e=>{let{coreStrategies:t}=e,n=new Set,a=new Map(Object.entries(t));const i=e=>n=new Set([...e]);return Object.freeze({add:e=>{if(r.invariant(Oe.includes(e.type),`Service Plugin type ${e.type} is not supported`),"discovery-service"===e.type){const{discoveryServices:t,serviceStrategy:n}=(e=>{const{services:t=[],serviceStrategy:n}=e;r.invariant(Array.isArray(t),"Services must be an array");for(const e of t)r.invariant(I(e.f_type)&&"Service"===e.f_type,"Service is required"),r.invariant(I(e.type)&&"authn"===e.type,`Service must be type authn. Received ${e.type}`),r.invariant(e.method in M||n.method===e.method,`Service method ${e.method} is not supported`);return r.invariant(I(n),"Service strategy is required"),r.invariant(I(n.method)&&C(n.method),"Service strategy method is required"),r.invariant(I(n.exec)&&A(n.exec),"Service strategy exec function is required"),{discoveryServices:t,serviceStrategy:n}})(e);i(t),a.has(n.method)?o.log({title:"Add Service Plugin",message:`Service strategy for ${n.method} already exists`,level:o.LEVELS.warn}):a.set(n.method,n.exec)}},getServices:()=>[...n],getStrategy:e=>a.get(e),getStrategies:()=>[...a.keys()]})};let Ne;const je=()=>void 0!==Ne,xe=e=>{let{coreStrategies:t}=e;if(je())return Ne;const n=_e({coreStrategies:t});return Ne=n,n},Le=()=>je()?Ne:(console.warn("Registry is not initalized, it will be initialized with stub core strategies"),xe({coreStrategies:Re})),Ue=(()=>{const e=new Map;return Object.freeze({add:t=>{const n=(e=>{let t;r.invariant(!!e,"No plugins supplied"),t=Array.isArray(e)?[...e]:[e];for(const e of t)r.invariant(I(e.name),"Plugin name is required"),r.invariant(I(e.f_type),"Plugin f_type is required"),r.invariant(ke.includes(e.f_type),`Plugin type ${e.f_type} is not supported`);return t})(t);for(const t of n)e.set(t.name,t),"ServicePlugin"===t.f_type&&Ne.add(t)},getPlugins:()=>e})})(),De=async()=>[...window?.fcl_extensions||[],...Le().getServices()];async function Fe(e){const t=await i.config.get("discovery.authn.include",[]),n=await i.config.get("discovery.features.suggested",[]),a=await i.config.first(["discovery.wallet.method","discovery.wallet.method.default"]),o=e?.method?e.method:a,s=e?.endpoint??await i.config.first(["discovery.wallet","challenge.handshake"]);return r.invariant(s,'\n    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.\n    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"\n    '),{...e,type:"authn",endpoint:s,method:o,discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}}const Be="authn",$e="SNAPSHOT",ze="UPDATED",Me="UPDATE_RESULTS",He=async()=>{try{const e=await async function(e){let{types:t}=e;const n=await i.config.get("discovery.authn.endpoint");r.invariant(Boolean(n),'"discovery.authn.endpoint" in config must be defined.');const a=await i.config.get("discovery.authn.include",[]),o=new K(n);return fetch(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:t,fclVersion:P,include:a,features:{suggested:await i.config.get("discovery.features.suggested",[])},clientServices:await De(),supportedStrategies:Le().getStrategies(),userAgent:window?.navigator?.userAgent,network:await U()})}).then((e=>e.json()))}({types:[Be]});l.send(Be,Me,{results:e})}catch(e){o.log({title:`${e.name} Error fetching Discovery API services.`,message:e.message,level:o.LEVELS.error})}},qe={[l.INIT]:async e=>{var t,n;t="undefined"==typeof window,n='"fcl.discovery" is only available in the browser.',t&&console.warn(`\n      %cFCL Warning\n      ============================\n      ${n}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `,"font-weight:bold;font-family:monospace;"),"complete"===document.readyState?He():window.addEventListener("load",(()=>{He()}))},[Me]:(e,t,n)=>{e.merge(n),e.broadcast(ze,{...e.all()})},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,ze,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>e.unsubscribe(t.from),[$e]:async(e,t)=>t.reply({...e.all()})},Ve=()=>l.spawn(qe,Be),We={authn:{subscribe:e=>l.subscriber(Be,Ve,e),snapshot:()=>l.snapshoter(Be,Ve),update:()=>{"complete"===document.readyState&&He()}}};function Ke(e){const t=new f.SHA3(256);return t.update(c.Buffer.from(e,"utf8")),t.digest("hex")}function Ge(e){let{contractName:t,address:n}=e;return{contractName:t,address:n,contract:""}}function Je(e){const t=[],n=e.match(/import ((\w|,| )+)* from 0x\w+/g)||[];for(const e of n){const n=/import ((\w+|, |)*) from (0x\w+)/g.exec(e),r=/((?:\w+)+),?/g,a=n[1].match(r)||[];for(const e of a)t.push(Ge({address:n[3],contractName:e.replace(/,/g,"")}))}return t}async function Ye(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[Ge({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Je(e.contract);i.push(...r)}const o=i.map((e=>Ke(e.contract)));return Ke((await Promise.all(o)).join(""))}async function Xe(e,t){const n=[];for(const r of t){const t=[Ke(r.network)],{address:a,dependency_pin_block_height:i}=r;if(r.dependency_pin){const n=await Ye({address:a,contractName:e,blockHeight:i});t.push(Ke(n))}n.push(t)}return n}async function Ze(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n],a=[];for(let e=0;e<r?.contracts.length;e++){const t=r?.contracts[e],n=t?.contract;a.push(Ke(n));const i=await Xe(n,t?.networks);a.push(i)}t.push(a)}return t}async function Qe(e){let{template:n}=e;switch(r.invariant(n,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),n.f_version){case"1.1.0":return await async function(e){let{template:t}=e;r.invariant(t,"generateTemplateId({ template }) -- template must be defined"),r.invariant("object"==typeof t,"generateTemplateId({ template }) -- template must be an object"),r.invariant("InteractionTemplate"===t.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),r.invariant("1.1.0"===t.f_version,"generateTemplateId({ template }) -- template object must be an version 1.1.0");const n=t.data,a=await Promise.all(n.messages.map((async e=>[Ke(e.key),await Promise.all(e.i18n.map((async e=>[Ke(e.tag),Ke(e.translation)])))]))),i=await Promise.all(n?.parameters.sort(((e,t)=>e.index-t.index)).map((async e=>[Ke(e.label),[Ke(String(e.index)),Ke(e.type),await Promise.all(e.messages.map((async e=>[Ke(e.key),await Promise.all(e.i18n.map((async e=>[Ke(e.tag),Ke(e.translation)])))])))]]))),o=[await Ze(n?.dependencies)],s=c.encode([Ke(t?.f_type),Ke(t?.f_version),Ke(n?.type),Ke(n?.interface),a,Ke(n?.cadence?.body),[o],i]).toString("hex");return Ke(s)}({template:n});case"1.0.0":return await async function(e){let{template:n}=e;t.invariant(null!=n,"generateTemplateId({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateTemplateId({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateTemplateId({ template }) -- template object must be an InteractionTemplate"),t.invariant("1.0.0"===n.f_version,"generateTemplateId({ template }) -- template object must be an version 1.0.0");const r=n.data,a=await Promise.all(Object.keys(r.messages).map((async e=>[Ke(e),await Promise.all(Object.keys(r.messages?.[e]?.i18n).map((async t=>[Ke(t),Ke(r.messages?.[e]?.i18n?.[t])])))]))),i=await Promise.all(Object.keys(r?.dependencies).map((async e=>[Ke(e),await Promise.all(Object.keys(r?.dependencies?.[e]).map((async t=>[Ke(t),await Promise.all(Object.keys(r?.dependencies?.[e]?.[t]).map((async n=>[Ke(n),[Ke(r?.dependencies?.[e]?.[t]?.[n].address),Ke(r?.dependencies?.[e]?.[t]?.[n].contract),Ke(r?.dependencies?.[e]?.[t]?.[n].fq_address),Ke(r?.dependencies?.[e]?.[t]?.[n].pin),Ke(String(r?.dependencies?.[e]?.[t]?.[n].pin_block_height))]])))])))]))),o=await Promise.all(Object.keys(r?.arguments).map((async e=>[Ke(e),[Ke(String(r?.arguments?.[e].index)),Ke(r?.arguments?.[e].type),Ke(r?.arguments?.[e].balance||""),await Promise.all(Object.keys(r?.arguments?.[e].messages).map((async t=>[Ke(t),await Promise.all(Object.keys(r?.arguments?.[e].messages?.[t].i18n).map((async n=>[Ke(n),Ke(r?.arguments?.[e].messages?.[t].i18n?.[n])])))])))]]))),s=c.encode([Ke("InteractionTemplate"),Ke("1.0.0"),Ke(r?.type),Ke(r?.interface),a,Ke(r?.cadence),i,o]).toString("hex");return Ke(s)}({template:n});default:throw new Error("generateTemplateId Error: Unsupported template version")}}async function et(e){let{version:n,address:r,contractName:a}=e;switch(t.invariant(null!=r,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=a,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof a,"generateDependencyPin({ contractName }) -- contractName must be a string"),n){case"1.1.0":return await Ye({address:r,contractName:a});case"1.0.0":return await async function(e){let{address:n,contractName:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"generateDependencyPin({ address }) -- address must be defined"),t.invariant(null!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),t.invariant("string"==typeof n,"generateDependencyPin({ address }) -- address must be a string"),t.invariant("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");const i=[Ge({contractName:r,address:n})];for(const e of i){const n=await t.send([t.getAccount(await t.config().get(e.address,e.address))],a).then(t.decode);if(e.contract=n.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,n),new Error("Did not find expected contract");const r=Je(e.contract);i.push(...r)}const o=i.map((e=>Ke(e.contract)));return Ke(o.join(""))}({address:r,contractName:a});default:throw new Error("deriveCadenceByNetwork Error: Unsupported template version")}}async function tt(e){let{template:n,blockHeight:r,network:a}=e;switch(t.invariant(null!=n,"generateDependencyPin({ template }) -- template must be defined"),t.invariant("object"==typeof n,"generateDependencyPin({ template }) -- template must be an object"),t.invariant("InteractionTemplate"===n.f_type,"generateDependencyPin({ template }) -- template must be an InteractionTemplate"),t.invariant(null!=a,"generateDependencyPin({ network }) network must be defined"),t.invariant(null!=r,"generateDependencyPin({ blockHeight }) blockHeight must be defined"),t.invariant("number"==typeof r,"generateDependencyPin({ blockHeight }) blockHeight must be a number"),n.f_version){case"1.0.0":const e=Object.keys(n.data.dependencies);for(let t of e){const e=n.data.dependencies[t],i=Object.keys(e);for(let e of i){const i=n.data.dependencies[t][e][a];if(void 0===i)continue;const s=await et({address:i.address,contractName:i.contract,blockHeight:r});if(s!==i.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                address: ${i.address} | contract: ${i.contract}\n                                computed: ${s}\n                                template: ${i.pin}\n                            `,level:o.LEVELS.debug}),!1}}return!0;case"1.1.0":let t=!1;for(let e=0;e<n.data?.dependencies.length;e++){const i=n.data?.dependencies[e];for(let e=0;e<i?.contracts.length;e++){const s=i?.contracts[e];for(let e=0;e<s?.networks.length;e++){const i=s?.networks[e];if(i.network===a){const e=await et({version:n.f_version,address:i.address,contractName:s.contract,blockHeight:r});if(e!==i.dependency_pin.pin)return o.log({title:"verifyDependencyPinsSame Debug Error",message:`Could not recompute and match dependency pin.\n                                    address: ${i.address} | contract: ${s.contract}\n                                    computed: ${e}\n                                    template: ${i.pin}\n                                `,level:o.LEVELS.debug}),!1;t=!0}}}}return t;default:throw new Error("verifyDependencyPinsSame Error: Unsupported template version")}}var nt=Object.freeze({__proto__:null,deriveCadenceByNetwork:j,generateDependencyPin:et,generateDependencyPinAtLatestSealedBlock:async function(e){let{version:n,address:r,contractName:a}=e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=await t.block({sealed:!0},i),s=o?.height;return et({version:n,address:r,contractName:a,blockHeight:s})},generateTemplateId:Qe,getInteractionTemplateAudits:async function(e){let{template:n,auditors:r}=e,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.invariant(null!=n,"getInteractionTemplateAudits({ template }) -- template must be defined"),t.invariant("InteractionTemplate"===n.f_type,"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");let i=await Qe({template:n});if(i!==n.id)throw o.log({title:"getInteractionTemplateAudits Debug Error",message:`Could not recompute and match template ID\n                computed: ${i}\n                template: ${n.id}\n            `,level:o.LEVELS.debug}),new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");switch(n.f_version){case"1.1.0":case"1.0.0":const e=r||await t.config().get("flow.auditors");t.invariant(e,"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set"),t.invariant(Array.isArray(e),"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");let n=a.flowInteractionAuditContract;if(!n){const e=await U(a);t.invariant("mainnet"===e||"testnet"===e,"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'"),n="mainnet"===e?"0xfd100e39d50a13e6":"0xf78bfc12d0a786dc"}const o=await B({cadence:`\n        import FlowInteractionTemplateAudit from ${n}\n        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,args:(t,n)=>[t(i,n.String),t(e,n.Array(n.Address))]});return o;default:throw new Error("getInteractionTemplateAudits Error: Unsupported template version")}},getTemplateArgumentMessage:function(e){let{localization:n="en-US",argumentLabel:r,messageKey:a,template:i}=e;switch(t.invariant(a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string"),t.invariant(r,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined"),t.invariant("string"==typeof a,"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string"),t.invariant(n,"getTemplateArgumentMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateArgumentMessage({ localization }) -- localization must be a string"),t.invariant(null!=i,"getTemplateArgumentMessage({ template }) -- template must be defined"),t.invariant("object"==typeof i,"getTemplateArgumentMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof i.f_type,"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate"),i.f_version){case"1.1.0":const e=i?.data?.parameters?.find((e=>e.label===r));if(!e)return;const t=e?.messages?.find((e=>e.key===a));if(!t)return;const o=t?.i18n?.find((e=>e.tag===n));if(!o)return;return o.translation;case"1.0.0":return i?.data?.arguments?.[r]?.messages?.[a]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},getTemplateMessage:function(e){let{localization:n="en-US",messageKey:r,template:a}=e;switch(t.invariant(r,"getTemplateMessage({ messageKey }) -- messageKey must be defined"),t.invariant("string"==typeof r,"getTemplateMessage({ messageKey }) -- messageKey must be a string"),t.invariant(n,"getTemplateMessage({ localization }) -- localization must be defined"),t.invariant("string"==typeof n,"getTemplateMessage({ localization }) -- localization must be a string"),t.invariant(null!=a,"getTemplateMessage({ template }) -- template must be defined"),t.invariant("object"==typeof a,"getTemplateMessage({ template }) -- template must be an object"),t.invariant("InteractionTemplate"==typeof a.f_type,"getTemplateMessage({ template }) -- template object must be an InteractionTemplate"),a.f_version){case"1.1.0":const e=a?.data?.messages?.find((e=>e.key===r));if(!e)return;const t=e?.i18n?.find((e=>e.tag===n));if(!t)return;return t.translation;case"1.0.0":return a?.data?.messages?.[r]?.i18n?.[n];default:throw new Error("getTemplateArgumentMessage Error: Unsupported template version")}},verifyDependencyPinsSame:tt,verifyDependencyPinsSameAtLatestSealedBlock:async function(e){let{template:n,network:r}=e;const a=await t.block({sealed:!0}),i=a?.height;return tt({template:n,network:r,blockHeight:i})},verifyGeneratedTemplateId:async function(e){let{template:t}=e;return t.id===await Qe({template:t})}});function rt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{old:e,...J,type:"frame",endpoint:e.endpoint,params:e.params||{},data:e.data||{}}}function at(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...J,type:"back-channel-rpc",endpoint:e.endpoint,method:e.method,params:e.params||{},data:e.data||{}}}function it(e){return null==e?null:(null==e.method&&(e={...e,type:"local-view",method:"VIEW/IFRAME"}),e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...J,type:e.type||"local-view",method:e.method,endpoint:e.endpoint,data:e.data||{},params:e.params||{}})}function ot(e,t){return e.map((e=>function(e,t){try{return st[e.type](e,t)}catch(t){return console.error(`Unrecognized FCL Service Type [${e.type}]`,e,t),e}}(e,t))).filter(Boolean)}const st={"back-channel-rpc":at,"pre-authz":function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...J,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Y,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authz:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...J,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Y,address:s.withPrefix(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authn:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...J,type:e.type,uid:e.id,endpoint:e.authn,id:e.pid,provider:{address:s.withPrefix(e.addr),name:e.name,icon:e.icon}}},frame:rt,"open-id":function(e){return null==e?null:"1.0.0"===e.f_vsn?e:null},"user-signature":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid user-signature service");return"1.0.0"===e.f_vsn?e:null},"local-view":it,"account-proof":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("FCL Normalizer Error: Invalid account-proof service");return"1.0.0"===e.f_vsn?e:null},"authn-refresh":function(e){if(null==e)return null;if(!e.f_vsn)throw new Error("Invalid authn-refresh service");return"1.0.0"===e.f_vsn?e:null}};function ct(){let e=arguments.length>1?arguments[1]:void 0;return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).reduce(((t,n)=>n.type===e&&(!t||E.compare(n.f_vsn,t.f_vsn)>0)?n:t),null)}function lt(e){return w.encode([e.provider?.address||e.provider?.name||"UNSPECIFIED",e.id]).toString("hex")}async function dt(e){var t=ot(function(){return[...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],...arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]]}((e=function(e){return e.addr=e.addr?s.withPrefix(e.addr):null,e.paddr=e.paddr?s.withPrefix(e.paddr):null,e}(e)).services||[],await async function(e,t){if(null==e||null==t)return[];const n=new K(e);n.searchParams.append("code",t);const r=await fetch(n,{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>e.json()));if(Array.isArray(r))return r;const a=[];if(Array.isArray(r.authorizations))for(let e of r.authorizations)a.push({type:"authz",keyId:r.keyId,...e});return null!=r.provider&&a.push({type:"authn",id:"wallet-provider#authn",...r.provider}),a}(e.hks,e.code)));const n=ct(t,"authn");return{...X,addr:s.withPrefix(e.addr),cid:lt(n),loggedIn:!0,services:t,expiresAt:e.expires}}const ut="undefined"==typeof window;const pt=globalThis.AbortController||require("abort-controller"),ft=async e=>{let{service:t,body:n,config:r,abortSignal:a,customRpc:i,user:o,opts:s}=e;return Le().getStrategy(t.method)({service:t,body:n,config:r,abortSignal:a,customRpc:i,opts:s,user:o})};async function gt(e){let{service:t,msg:n={},config:a={},opts:i={},platform:s,abortSignal:c=(new pt).signal,execStrategy:l,user:d}=e;!function(){if(ut)return;Le().getStrategies().includes("WC/RPC")||b.log({title:"FCL WalletConnect Service Plugin",level:b.LEVELS.error,message:"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."})}(),n.data=t.data;const u={services:await le(/^service\./),app:await le(/^app\.detail\./),client:{...a.client,platform:s,fclVersion:P,fclLibrary:"https://github.com/onflow/fcl-js",hostname:window?.location?.hostname??null,network:await U(i)}};try{const e=await(l||ft)({service:t,body:n,config:u,opts:i,user:d,abortSignal:c});return"REDIRECT"===e.status?(r.invariant(t.type===e.data.type,"Cannot shift recursive service type in execService"),await gt({service:e.data,msg:n,config:u,opts:i,abortSignal:c,platform:s,user:d})):e}catch(e){throw o.log({title:`Error on execService ${t?.type}`,message:e,level:o.LEVELS.error}),e}}function mt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Q,addr:s.sansPrefix(e.addr||e.address),signature:e.signature||e.sig,keyId:e.keyId}}const yt="CURRENT_USER",vt="CURRENT_USER/UPDATED",ht="SNAPSHOT",bt="SET_CURRENT_USER",wt="DEL_CURRENT_USER",Et='{\n  "f_type": "User",\n  "f_vsn": "1.0.0",\n  "addr":null,\n  "cid":null,\n  "loggedIn":null,\n  "expiresAt":null,\n  "services":[]\n}',Pt=e=>{const t=async()=>e.getStorageProvider?await e.getStorageProvider():await i.config.first(["fcl.storage","fcl.storage.default"]);return{[l.INIT]:async e=>{"undefined"==typeof window&&console.warn('\n        %cFCL Warning\n        ============================\n        "currentUser" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ',"font-weight:bold;font-family:monospace;"),e.merge(JSON.parse(Et));const n=await t();if(n.can){const t=await(async e=>{const t=JSON.parse(Et),n=await e.get(yt);return null!=n&&t.f_vsn!==n.f_vsn?(e.removeItem(yt),t):n||t})(n);(function(e){return null==e.expiresAt||0===e.expiresAt||e.expiresAt>Date.now()})(t)&&e.merge(t)}},[l.SUBSCRIBE]:(e,t)=>{e.subscribe(t.from),e.send(t.from,vt,{...e.all()})},[l.UNSUBSCRIBE]:(e,t)=>{e.unsubscribe(t.from)},[ht]:async(e,t)=>{t.reply({...e.all()})},[bt]:async(e,n,r)=>{e.merge(r);const a=await t();a.can&&a.put(yt,e.all()),e.broadcast(vt,{...e.all()})},[wt]:async(e,n)=>{e.merge(JSON.parse(Et));const r=await t();r.can&&r.put(yt,e.all()),e.broadcast(vt,{...e.all()})}}},St=e=>l.spawn(Pt(e),yt);async function It(){let e=await i.config.get("fcl.accountProof.resolver");if(null==e)return;if("function"!=typeof e)return void o.log({title:"Account Proof Data Resolver must be a function",message:`Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof e}\n                `,level:o.LEVELS.warn});const t=await e();return null!=t?(r.invariant("string"==typeof t.appIdentifier,"appIdentifier must be a string"),r.invariant(/^[0-9a-f]+$/i.test(t.nonce),"Nonce must be a hex string"),t):void 0}const Tt=async e=>{let{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n}=e;return{client:{discoveryAuthnInclude:t,discoveryFeaturesSuggested:n,clientServices:await De(),supportedStrategies:Le().getStrategies()}}},Ct=e=>async function(){let{service:t,redir:n=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!t||t?.provider?.is_installed||!t?.provider?.requires_install)return new Promise((async(r,a)=>{St(e);const i={redir:n},s=await Ot(e)(),c=await Fe(t),d=ct(s.services,"authn-refresh");let u;if(s.loggedIn){if(!d)return r(s);try{const t=await gt({service:d,msg:u,opts:i,platform:e.platform,user:s});l.send(yt,bt,await dt(t))}catch(e){o.log({title:`${e.name} Could not refresh wallet authentication.`,message:e.message,level:o.LEVELS.error})}finally{return r(await Ot(e)())}}try{u=await It()}catch(e){return o.log({title:`${e.name} On Authentication: Could not resolve account proof data.`,message:e.message,level:o.LEVELS.error}),a(e)}try{const t=await gt({service:c,msg:u,config:await Tt(c),opts:i,platform:e.platform,execStrategy:e.discovery?.execStrategy,user:s});l.send(yt,bt,await dt(t))}catch(e){o.log({title:`${e} On Authentication`,message:e,level:o.LEVELS.error})}finally{r(await Ot(e)())}}));window.location.href=t?.provider?.install_link};function At(e){return function(){St(e),l.send(yt,wt)}}const Rt=e=>async t=>(St(e),{...t,tempId:"CURRENT_USER",async resolve(t,n){const r=await Ct(e)({redir:!0}),a=ct(r.services,"authz"),i=ct(r.services,"pre-authz");if(i)return(e=>(t,n)=>{let{user:r}=n;const a=(e=>({f_type:"PreAuthzResponse",f_vsn:"1.0.0",proposer:(e||{}).proposer,payer:(e||{}).payer||[],authorization:(e||{}).authorization||[]}))(t),i=[];null!=a.proposer&&i.push(["PROPOSER",a.proposer]);for(let e of a.payer||[])i.push(["PAYER",e]);for(let e of a.authorization||[])i.push(["AUTHORIZER",e]);return i.map((t=>{let[n,a]=t;return{tempId:[a.identity.address,a.identity.keyId].join("|"),addr:a.identity.address,keyId:a.identity.keyId,signingFunction:t=>gt({service:a,msg:t,platform:e.platform,user:r}),role:{proposer:"PROPOSER"===n,payer:"PAYER"===n,authorizer:"AUTHORIZER"===n}}}))})(e)(await gt({service:i,msg:n,platform:e.platform,user:r}),{user:r});if(a)return{...t,tempId:"CURRENT_USER",resolve:null,addr:s.sansPrefix(a.identity.address),keyId:a.identity.keyId,sequenceNum:null,signature:null,signingFunction:async t=>mt(await gt({service:a,msg:t,opts:{includeOlderJsonRpcCall:!0},platform:e.platform,user:r}))};throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER")}});function kt(e){return function(t){St(e);const n="@EXIT",r=l.spawn((async e=>{for(e.send(yt,l.SUBSCRIBE);;){const r=await e.receive();if(r.tag===n)return void e.send(yt,l.UNSUBSCRIBE);t(r.data)}}));return()=>l.send(r,n)}}function Ot(e){return function(){return St(e),l.send(yt,ht,null,{expectReply:!0,timeout:0})}}const _t=e=>async()=>{const{addr:n}=await Ct(e)();return t.arg(s.withPrefix(n),h.Address)},Nt=e=>(r.invariant(/^[0-9a-f]+$/i.test(e),"Message must be a hex string"),{message:e}),jt=e=>async t=>{St(e);const n=await Ct(e)({redir:!0}),a=ct(n.services,"user-signature");r.invariant(a,"Current user must have authorized a signing service.");try{const r=await gt({service:a,msg:Nt(t),platform:e.platform,user:n});return Array.isArray(r)?r.map((e=>mt(e))):[mt(r)]}catch(e){return e}},xt=e=>{const t={authenticate:Ct(e),unauthenticate:At(e),authorization:Rt(e),signUserMessage:jt(e),subscribe:kt(e),snapshot:Ot(e),resolveArgument:_t(e)};return Object.assign((()=>({...t})),{...t})};function Lt(e){const t=new K(e.endpoint);if(window?.location?.origin&&t.searchParams.append("l6n",window.location.origin),null!=e.params)for(let[n,r]of Object.entries(e.params||{}))t.searchParams.append(n,r);return t}function Ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=t.method||"POST",r="GET"===n?void 0:JSON.stringify(t.data||e.data||{});return fetch(Lt(e),{method:n,headers:{...e.headers||{},...t.headers||{},"Content-Type":"application/json"},body:r}).then((e=>e.json()))}function Dt(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Z,status:e.status??"APPROVED",reason:e.reason??null,data:e.compositeSignature||e.data||{...e}||{},updates:at(e.authorizationUpdates),local:rt((e.local||[])[0])}}const Ft={"HTTP/GET":"GET","HTTP/POST":"POST"},Bt=e=>(r.invariant(Ft[e.method],"Invalid Service Method for type back-channel-rpc",{service:e}),Ft[e.method]);async function $t(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>!0;r.invariant(e,"Missing Polling Service",{service:e});if(!t())throw new Error("Externally Halted");let n;try{if("undefined"!=typeof document&&"hidden"===document.visibilityState)return await new Promise((e=>setTimeout(e,500))),$t(e,t);n=await Ut(e,{method:Bt(e)}).then(Dt)}catch(e){throw e}switch(n.status){case"APPROVED":return n.data;case"DECLINED":throw new Error(`Declined: ${n.reason||"No reason supplied."}`);default:return await new Promise((e=>setTimeout(e,500))),$t(n.updates,t)}}const zt="FCL:VIEW:CLOSE",Mt="FCL:VIEW:READY",Ht="FCL:VIEW:RESPONSE",qt=e=>"string"==typeof e&&e.toLowerCase(),Vt=new Set(["monetizationstart","monetizationpending","monetizationprogress","monetizationstop"]),Wt=(e,t)=>console.warn("DEPRECATION NOTICE",`Received ${e}, please use ${t} for this and future versions of FCL`);i.config.subscribe((()=>{U({enableRequestLogging:!1}).catch((()=>{}))})),Object.defineProperty(e,"TestUtils",{enumerable:!0,get:function(){return t.TestUtils}}),Object.defineProperty(e,"account",{enumerable:!0,get:function(){return t.account}}),Object.defineProperty(e,"arg",{enumerable:!0,get:function(){return t.arg}}),Object.defineProperty(e,"args",{enumerable:!0,get:function(){return t.args}}),Object.defineProperty(e,"atBlockHeight",{enumerable:!0,get:function(){return t.atBlockHeight}}),Object.defineProperty(e,"atBlockId",{enumerable:!0,get:function(){return t.atBlockId}}),Object.defineProperty(e,"authorization",{enumerable:!0,get:function(){return t.authorization}}),Object.defineProperty(e,"authorizations",{enumerable:!0,get:function(){return t.authorizations}}),Object.defineProperty(e,"block",{enumerable:!0,get:function(){return t.block}}),Object.defineProperty(e,"build",{enumerable:!0,get:function(){return t.build}}),Object.defineProperty(e,"createSignableVoucher",{enumerable:!0,get:function(){return t.createSignableVoucher}}),Object.defineProperty(e,"decode",{enumerable:!0,get:function(){return t.decode}}),Object.defineProperty(e,"getAccount",{enumerable:!0,get:function(){return t.getAccount}}),Object.defineProperty(e,"getBlock",{enumerable:!0,get:function(){return t.getBlock}}),Object.defineProperty(e,"getBlockHeader",{enumerable:!0,get:function(){return t.getBlockHeader}}),Object.defineProperty(e,"getCollection",{enumerable:!0,get:function(){return t.getCollection}}),Object.defineProperty(e,"getEvents",{enumerable:!0,get:function(){return t.getEvents}}),Object.defineProperty(e,"getEventsAtBlockHeightRange",{enumerable:!0,get:function(){return t.getEventsAtBlockHeightRange}}),Object.defineProperty(e,"getEventsAtBlockIds",{enumerable:!0,get:function(){return t.getEventsAtBlockIds}}),Object.defineProperty(e,"getNetworkParameters",{enumerable:!0,get:function(){return t.getNetworkParameters}}),Object.defineProperty(e,"getNodeVersionInfo",{enumerable:!0,get:function(){return t.getNodeVersionInfo}}),Object.defineProperty(e,"getTransaction",{enumerable:!0,get:function(){return t.getTransaction}}),Object.defineProperty(e,"getTransactionStatus",{enumerable:!0,get:function(){return t.getTransactionStatus}}),Object.defineProperty(e,"invariant",{enumerable:!0,get:function(){return t.invariant}}),Object.defineProperty(e,"isBad",{enumerable:!0,get:function(){return t.isBad}}),Object.defineProperty(e,"isOk",{enumerable:!0,get:function(){return t.isOk}}),Object.defineProperty(e,"limit",{enumerable:!0,get:function(){return t.limit}}),Object.defineProperty(e,"nodeVersionInfo",{enumerable:!0,get:function(){return t.nodeVersionInfo}}),Object.defineProperty(e,"param",{enumerable:!0,get:function(){return t.param}}),Object.defineProperty(e,"params",{enumerable:!0,get:function(){return t.params}}),Object.defineProperty(e,"payer",{enumerable:!0,get:function(){return t.payer}}),Object.defineProperty(e,"ping",{enumerable:!0,get:function(){return t.ping}}),Object.defineProperty(e,"pipe",{enumerable:!0,get:function(){return t.pipe}}),Object.defineProperty(e,"proposer",{enumerable:!0,get:function(){return t.proposer}}),Object.defineProperty(e,"ref",{enumerable:!0,get:function(){return t.ref}}),Object.defineProperty(e,"script",{enumerable:!0,get:function(){return t.script}}),Object.defineProperty(e,"send",{enumerable:!0,get:function(){return t.send}}),Object.defineProperty(e,"subscribeEvents",{enumerable:!0,get:function(){return t.subscribeEvents}}),Object.defineProperty(e,"transaction",{enumerable:!0,get:function(){return t.transaction}}),Object.defineProperty(e,"validator",{enumerable:!0,get:function(){return t.validator}}),Object.defineProperty(e,"voucherIntercept",{enumerable:!0,get:function(){return t.voucherIntercept}}),Object.defineProperty(e,"voucherToTxId",{enumerable:!0,get:function(){return t.voucherToTxId}}),Object.defineProperty(e,"why",{enumerable:!0,get:function(){return t.why}}),e.t=h,Object.defineProperty(e,"config",{enumerable:!0,get:function(){return i.config}}),Object.defineProperty(e,"display",{enumerable:!0,get:function(){return s.display}}),Object.defineProperty(e,"sansPrefix",{enumerable:!0,get:function(){return s.sansPrefix}}),Object.defineProperty(e,"withPrefix",{enumerable:!0,get:function(){return s.withPrefix}}),Object.defineProperty(e,"cadence",{enumerable:!0,get:function(){return g.template}}),Object.defineProperty(e,"cdc",{enumerable:!0,get:function(){return g.template}}),e.AppUtils=se,e.CORE_STRATEGIES=M,e.FCL_REDIRECT_URL_PARAM_NAME=$,e.FCL_RESPONSE_PARAM_NAME=z,e.InteractionTemplateUtils=nt,e.URL=K,e.VERSION=P,e.WalletUtils=re,e.buildMessageHandler=e=>{let t,{close:n,send:r,onReady:a,onResponse:i,onMessage:o,onCustomRpc:s,getSource:c}=e;return e=>{try{t=c?.()||t}catch(e){t=null}try{if("object"!=typeof e.data)return;if(Vt.has(e.data.type))return;if(null!=t&&e.source!==t)return;qt(e.data.type)===qt(zt)&&n(),qt(e.data.type)===qt(Mt)&&(a(e,{send:r,close:n}),t||=e.source),qt(e.data.type)===qt(Ht)&&i(e,{send:r,close:n}),qt(e.data.type)===qt("FCL:VIEW:CUSTOM_RPC")&&s(e.data.payload,{send:r,close:n}),o(e,{send:r,close:n}),qt(e.data.type)===qt("FCL:FRAME:READY")&&(Wt(e.data.type,Mt),a(e,{send:r,close:n}),t||=e.source),qt(e.data.type)===qt("FCL:FRAME:RESPONSE")&&(Wt(e.data.type,Ht),i(e,{send:r,close:n})),qt(e.data.type)===qt("FCL:FRAME:CLOSE")&&(Wt(e.data.type,zt),n()),qt(e.data.type)===qt("FCL::CHALLENGE::RESPONSE")&&(Wt(e.data.type,Ht),i(e,{send:r,close:n})),qt(e.data.type)===qt("FCL::AUTHZ_READY")&&(Wt(e.data.type,Mt),a(e,{send:r,close:n}),t||=e.source),qt(e.data.type)===qt("FCL::CHALLENGE::CANCEL")&&(Wt(e.data.type,zt),n()),qt(e.data.type)===qt("FCL::CANCEL")&&(Wt(e.data.type,zt),n())}catch(e){console.error("Frame Callback Error",e),n()}}},e.discovery=We,e.events=function(e){let n;return n="string"==typeof e?{eventTypes:[e]}:e||{},{subscribe:r=>{const a=t.send([t.subscribeEvents(n)]).then(t.decode),i=a.then((()=>null)).catch((t=>{if("SDK Send Error: subscribeEvents is not supported by this transport."!==t.message)throw t;if("string"!=typeof e)throw new Error("GRPC fcl.events fallback only supports string (type) filters");return(n=e,{subscribe:e=>l.subscriber(n,Ce,e)}).subscribe(r);var n}));function o(e){e.forEach((e=>r(e,null)))}function s(e){r(null,e)}return i.then((e=>{e||a.then((e=>e.on("events",o).on("error",s))).catch((e=>{a.then((e=>e.close())),s(e)}))})),()=>{i.then((e=>{e?e():a.then((e=>e.close()))}))}}}},e.execStrategy=ft,e.getChainId=U,e.getCurrentUser=xt,e.getExecHttpPost=e=>async t=>{let{service:n,body:r,config:a,opts:i}=t;const o=await Ut(n,{data:{fclVersion:P,service:{params:n.params,data:n.data,type:n.type},config:a,...r}}).then(Dt);if("APPROVED"===o.status)return o.data;if("DECLINED"===o.status)throw new Error(`Declined: ${o.reason||"No reason supplied."}`);if("REDIRECT"===o.status)return o;if("PENDING"===o.status){var s=!0,c=!0;const[t,n]=await e(it(o.local),{serviceEndpoint:Lt,onClose:()=>c=!1}),r=()=>{try{n(),c=!1}catch(e){console.error("Frame Close Error",e)}},a=()=>{const e=s;return s=c,e};return $t(o.updates,a).then((e=>(r(),e))).catch((e=>{throw console.error(e),r(),e}))}throw console.error("Auto Decline: Invalid Response",{service:n,resp:o}),new Error("Auto Decline: Invalid Response")},e.getMutate=e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await async function(e){return F("mutate",e)}(t),t=await D(t);const n="function"==typeof e?e:xt(e),r=await v.config().get("fcl.authz",n().authorization);return v.send([v.transaction(t.cadence),v.args(k(t.args||[])),t.limit&&R(t.limit)&&v.limit(t.limit),v.proposer(t.proposer||t.authz||r),v.payer(t.payer||t.authz||r),v.authorizations(t.authorizations||[t.authz||r])]).then(v.decode)}catch(e){throw e}},e.initServiceRegistry=xe,e.isReactNative=V,e.normalizePollingResponse=Dt,e.pluginRegistry=Ue,e.query=B,e.serialize=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await t.config.first(["sdk.resolve"],n.resolve||t.resolve);return Array.isArray(e)&&(e=await t.pipe(t.interaction(),e)),JSON.stringify(t.createSignableVoucher(await r(e)),null,2)},e.serviceEndpoint=Lt,e.setIsReactNative=function(e){q=e},e.tx=Ee,e.verifyUserSignatures=ce}));
//# sourceMappingURL=fcl-core.umd.min.js.map
